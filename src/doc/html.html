<style>
  #header {
    position: fixed;
    height: 40px;
    top: 0;
    left: 0;
    right: 0;
    padding-top: calc(20px + constant(safe-area-inset-top));
    padding-top: calc(20px + env(safe-area-inset-top));
    background-color: rgba(0, 0, 0, .5);
    backdrop-filter: saturate(180%) blur(20px);
    z-index: 99;
    opacity: 0;
    transition: opacity .1s ease;
  }
  .header-inner {
    display: flex;
    max-width: 500px;
    margin: 0 auto;
    padding: 0 20px;
  }
  .placeholder {
    width: 100%;
    height: calc(50px + constant(safe-area-inset-top));
    height: calc(50px + env(safe-area-inset-top));
  }
  .back-btn {
    display: flex;
    height: 21px;
    cursor: pointer;
  }
  .back-icon {
    width: 21px;
    height: 21px;
    background-image: url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB3aWR0aD0nMTJweCcgaGVpZ2h0PScyMnB4JyB2aWV3Qm94PScwIDAgMTIgMjInIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc+PHRpdGxlPlBhdGg8L3RpdGxlPjxnIGlkPSdTeW1ib2xzJyBzdHJva2U9J25vbmUnIHN0cm9rZS13aWR0aD0nMScgZmlsbD0nbm9uZScgZmlsbC1ydWxlPSdldmVub2RkJz48ZyBpZD0nT3ZlcnJpZGVzL05hdmlnYXRpb24tQmFyL0xlZnQvQmFjay1CdXR0b24nIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC05LjAwMDAwMCwgLTExLjAwMDAwMCknIGZpbGw9JyMwMDdBRkYnIGZpbGwtcnVsZT0nbm9uemVybyc+PGcgaWQ9J1Bpbi1MZWZ0JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5LjAwMDAwMCwgMTEuNTAwMDAwKSc+PHBhdGggZD0nTTMuNjIxMzIwMzQsMTAuNSBMMTEuNTYwNjYwMiwyLjU2MDY2MDE3IEMxMi4xNDY0NDY2LDEuOTc0ODczNzMgMTIuMTQ2NDQ2NiwxLjAyNTEyNjI3IDExLjU2MDY2MDIsMC40MzkzMzk4MjggQzEwLjk3NDg3MzcsLTAuMTQ2NDQ2NjA5IDEwLjAyNTEyNjMsLTAuMTQ2NDQ2NjA5IDkuNDM5MzM5ODMsMC40MzkzMzk4MjggTDAuNDM5MzM5ODI4LDkuNDM5MzM5ODMgQy0wLjE0NjQ0NjYwOSwxMC4wMjUxMjYzIC0wLjE0NjQ0NjYwOSwxMC45NzQ4NzM3IDAuNDM5MzM5ODI4LDExLjU2MDY2MDIgTDkuNDM5MzM5ODMsMjAuNTYwNjYwMiBDMTAuMDI1MTI2MywyMS4xNDY0NDY2IDEwLjk3NDg3MzcsMjEuMTQ2NDQ2NiAxMS41NjA2NjAyLDIwLjU2MDY2MDIgQzEyLjE0NjQ0NjYsMTkuOTc0ODczNyAxMi4xNDY0NDY2LDE5LjAyNTEyNjMgMTEuNTYwNjYwMiwxOC40MzkzMzk4IEwzLjYyMTMyMDM0LDEwLjUgWicgaWQ9J1BhdGgnPjwvcGF0aD48L2c+PC9nPjwvZz48L3N2Zz4=");
    background-size: contain;
    background-repeat: no-repeat;
    cursor: pointer;
  }
  .back-text {
    line-height: 23px;
    font-size: 17px;
    color: #007AFF;
  }
  .doc {
    margin: 0 auto;
    padding: 0 20px;
    max-width: 500px;
    color: var(--mainColor, #fff);
  }
  .doc-title {
    font-size: 17px;
    margin-bottom: 20px;
    position: fixed;
    font-weight: bold;
    top: calc(20px + constant(safe-area-inset-top));
    top: calc(20px + env(safe-area-inset-top));
    left: 50%;
    transform: translateX(-50%);
    z-index: 110;
    max-width: 50%;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .doc-text {
    color: color(--mainColor .5);
  }
  .doc-code {
    margin: 12px 0;
    padding: 4px 12px;
    border-radius: 10px;
    background-color:rgba(255, 255, 255, 0.15);
  }
  p {
    color: #999;
    font-size: 15px;
  }
  small {
    color: #555;
  }
  b {
    border-radius: 4px;
    padding: 0 7px;
    color: #fff;
    font-size: 13px;
    font-weight: 600;
    background: rgba(255, 255, 255, .25);
    margin-right: 7px;
  }
  b.excl {
    background: #ed143d;
  }
  hr {
    border: 0;
    background:rgba(255, 255, 255, 0.3);
    height: 1px;
    margin: 25px 0;
  }
  li {
    font-size: 14px;
    color: #999;
  }
</style>
<div class="placeholder"></div>
<div class="doc">
  <div id="header">
    <div class="header-inner">
      <div class="back-btn" onclick="javascript: history.back()">
        <div class="back-icon"></div>
        <span class="back-text">列表</span>
      </div>
    </div>
  </div>

  <section id="page-content"></section>

  <template id="types">
    <div class="doc-title">Types</div>
    <div class="doc-code">
      <code-highlight type="js">

      </code-highlight>
    </div>
  </template>

  <template id="install">
    <div class="doc-title">Install & Preface</div>
    <p>使用 npm 安装</p>
    <div class="doc-code">
      <code-highlight type="bash">
        $ npm install lath --save
      </code-highlight>
    </div>
    <br />
    <p>
      Lath 是一个渐进式前端容器，其初始依赖非常小，仅有 1kb。
    </p>
    <p>
      它能够以按需加载的方式运行在所有现有 Web 页面中，通过核心的容器能力将该页面与关联页面进行无缝连接。
    </p>
    <hr />
    <h4>主要亮点</h4>
    <ul>
      <li><b>页面转场</b> 让你的页面域页面之间增加多种预设的转场效果</li>
      <li><b>无侵入</b> 在现有页面中异步引入，不阻塞原页面的加载逻辑</li>
      <li><b>Prefetch</b> 可预加载页面资源</li>
      <li><b>窗口管理</b> 复杂窗口管理，支持非同源“隧穿”</li>
      <li><b>历史管控</b> 自动规划历史记录</li>
      <li><b>自动内存管理</b> 智能管控，自动释放</li>
    </ul>
    <p><small>包括但不限于以上特点</small></p>
    <hr />
    <p>现在就让我们开始上手吧！</p>
    <p><small>荐：使用 Typescript 进行开发可查看类型提示。</small></p>
  </template>

  <template id="start">
    <div class="doc-title">Start</div>
    <p>将普一个通页面变为单页应用就像下面这样：</p>
    <div class="doc-code">
      <code-highlight type="js">
        import { createApplication } from 'lath'

        /**
         * "home": moduleName
         * "root": target element id
         */
        createApplication('home', 'root').then(application => {
          application.setting({
            modules: {
              frameworks: {...}, // sync config
              home: () => { // async config
                return new Promise(async (resolve, reject) => {
                  import('../home').then(resolve).catch(reject)
                })
              }
            }
          })

          // start app
          application.start()
        })
      </code-highlight>
    </div>
    <br />
    <p>我们可以简单的理解为每一个模块都是一个完整的页面，我们现在需要把这些页面的基本信息记录到这里，Lath 才能帮你完成无缝连接的体验。</p>
    <p>现在，在你的现有页面中引入 lath。使用 createApplication 方法定义当前页面为一个应用，第一个参数作为将此页面元素定义为该应用首页模块的唯一命名，第二个参数为定义元素的具体元素 id 或 目标元素本身。</p>
    <p>通过 createApplication 进行命名的模块，同时需要在 modules 配置中进行模块特性的配置。</p>
    <hr />
    <p>createApplication 实际上是一个加载器，工作完成后异步返回 Application。同时你也可以采用同步方法进行载入 Application。如下：</p>
    <div class="doc-code">
      <code-highlight type="js">
        import { Application } from 'lath/app'
        const application = new Application()
        application.setting({
          modules: {
            ...
          }
        })
      </code-highlight>
    </div>
    <hr />
    <p>Application 为 Lath 的核心类，在创建应用前我们需要通过 new 将其实力化操作，之后我们需要设置该应用所包含的模块配置信息。通过配置信息中的 “modules” 属性来依次表达其包含模块的具体属性。</p>
    <hr />
    <p>关于非同源页面的无缝连接体验请参考应用预配置章节（Preset Config）：[Tunneling] 中的配置。</p>
    <hr />
    <p>另，本文档后续将主要对应用启动时的预配置项，加载的模块配置，以及和新 API，主要三个方面展开介绍，在查看文档时请注意区分。</p>
  </template>

  <template id="title">
    <div class="doc-title">Title</div>
    <p>模块的标题，主要用于浏览器的窗口展示上。</p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: 'Home Page'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p><small>注：frameworks 与 system 类型模块可无需定义此项。</small></p>
    <br />
    <p>在单页应用中，页面标题会随着窗口模块发上改变，因此你需要一个名字以便告知浏览器如何称呼它。</p>
  </template>

  <template id="source">
    <div class="doc-title">Source</div>
    <p>定义模块的 HTML 源代码，该源代码将在容器内运行。</p>
    <p>有以下两种定义方式，选其中一种即可:</p>
    <p><small>1. 源码模式</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: 'Home Page',
            source: {
              html: `
                &lt;html lang="en">
                  &lt;head>&lt;/head>
                  &lt;body>
                    { anything }
                  &lt;/body>
                &lt;/html>
              `
            }
          }
        }
      </code-highlight>
    </div>
    <p><small>2. 链接模式</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: 'Home Page',
            source: {
              src: 'http://yoursite.com'
            }
          }
        }
      </code-highlight>
    </div>
    <p>使用链接模式时需符合同源策略，否者某些能力将无法开启，比如 Capture、Apply、Inject 等。</p>
    <p>若需要将非同源页面纳入模块体系，则需要将目标页面同样接入 lath，并开启“隧穿”模式，可参考Application 初始化的预配置项中的“tunneling”</p>
  </template>

  <template id="index">
    <div class="doc-title">Index</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>定义应用的默认入口模块。</p>
    <p><small>*value: string</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            index: 'home'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>当应用启动时将首先初始化模块名为 “home” 的模块内容。</p>
    <p><small>注：在框架模块 (即 [rel = frameworks]) 中必须指定 index 首页模块，除非你期望由框架模块来承载首屏内容。</small></p>
  </template>

  <template id="rel">
    <div class="doc-title">Rel</div>
    <p>用作定义模块的类型。</p>
    <p>Lath 具备窗口管理的能力，为满足复杂窗口交互的场景，我们将其共分为三种类型，普通模块类型：“module”、框架类型：“framework”、系统类型：“system”</p>
    <p><small>*value: 'module' | 'frameworks' | 'system'</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            rel: 'module'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>1. “system” 类型的模块是放置在 Main Tree 下的，切不随着任何的模块路由而改变的，比如 app 中的辅助浮标、日期/信号头部栏、系统下拉通知等等。比如下面视频中的 AssistiveTouch 功能就是一个“system” 类型的模块的功能。</p>
    <p>2. “framework” 类型则一般是具有框架模式的模块，比如淘宝首页中包含底部导航栏的部分，该导航栏是多个页面所共有的，所以它可以是一个框架层的模块，框架层的模块相对系统层的模块的区别是有着更低层的级别，比如窗口切换的时候框架层可以随之切换，而系统层则不会随之切换。</p>
    <p>3. “module” 类型则是最常见的类型，我们可以理解为一个纯粹的页面，同时模块类型还分为自由类型和嵌入类型，后面的 [free] 配置中会讲到。</p>
    <p><small>注：“framework” 框架类型的模块是唯一的。未定义该值时默认为 module 类型。</small></p>
  </template>

  <template id="free">
    <div class="doc-title">Free</div>
    <p>定义模块的窗口展示类型。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            free: true
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>该设置下模块以“全屏模式”运行，即不受框架模块的约束，假设框架模块是一个带有 tabBar 功能的模块，当该模块设置 free 为 true，此时模块将直接覆盖整个框架层运行，反之模块则会在框架层之内运行（即表现为 tabBar 覆盖在模块之上，如果你需要表现 tabBar，那你也许就应该这样做）。</p>
  </template>

  <template id="level">
    <div class="doc-title">Level</div>
    <p>对模块的显示层级的定义。</p>
    <p><small>value: number</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            level: 1
          }
        }
      </code-highlight>
    </div>
    <hr />
    <p>一般首页模块的层级为 0，根据页面访问层级逐渐增大。</p>
    <p>模块层级关系还将反应在转场动画上，从小到大为正向动画，反之从大到小时是逆向动画。</p>
    <p>当历史回退到层级为 0 的模块时，会触发 singleLock 事件，具体可查看 singleLock 配置中的相关描述。</p>
    <hr />
    <p>注意：若跳转的两个模块是为同层级模块，则转场动画效果会被自动关闭。</p>
    <p><small>为什么同级模块动画关闭？：同级模块动画关闭主要场景是用于 tab 切换，一般 tab 切换时不需要一个窗口动画效果，但是从其它层级的窗口切换过来时可能又是需要动画效果的。</small></p>
  </template>

  <template id="color">
    <div class="doc-title">Color</div>
    <p>定义模块的初始窗口背景色。</p>
    <p><small>value: string</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            color: '#bd243f'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>默认背景色可以在模块尚未加载完成时提供良好的视觉过渡。</p>
    <p>请选用合适的背景色来填充模块窗口，以确保动画效果的平滑度。</p>
    <p><small>注：请确保背景色与模块主色一致。未设置时，默认值会根据浏览器设置的颜色模式自动填充 黑色/白色。</small></p>
    <br />
    <p>点击按钮查看效果 <button onclick="javascript: window.parent.postMessage({ action: 'to', data: { module: 'empty' }})">Preview</button></p>
  </template>

  <template id="preset">
    <div class="doc-title">Animate Effect</div>
    <p>定义模块的窗口动画效果为预置的动画效果。</p>
    <p>Lath 提供了常见的动画效果选项，只需指定你的效果名称即可实现流畅的窗口动画。</p>
    <p><small>value: 'slide' ｜ 'slide-left' | 'slideLeft' | 'slideRight' | 'slide-right' | 'slideUp' | 'slide-up' | 'slideDown' | 'slide-down' | 'flip' | 'flipDown' | 'flip-down' | 'flip-up' | 'flipUp' | 'flipRight' | 'flip-right' | 'flipLeft' | 'flip-left' | 'zoom'</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            color: '#000',
            animation: 'slide'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>与‘slide’等效的动画名称： 'slide' ｜ 'slide-left' | 'slideLeft'。其他动画效果书写形式等同。</p>
    <hr />
    <p>模块未设置动画效果时会默认继承 frameworks 配置中的动画效果。</p>
    <p><small>注：新开窗口时的默认窗口效果为 slide。</small></p>
  </template>

  <template id="customEffect">
    <div class="doc-title">Custom Effect</div>
    <p>自定义模块的窗口动画效果。</p>
    <p><small>value: (e: TransformAnimateEvent) => void | Promise<boolean> ｜ </boolean> [(e: TransformAnimateEvent) => void | Promise<boolean>, (e: TransformAnimateEvent) => void | Promise<boolean></small></p>
    <div class="doc-code">
      <code-highlight type="js">
        const getAnimate = (type: number) => {
          return (e: TransformAnimateEvent) => {
            let inO: number, outO: number, inV: Animate, outV: Animate
            switch (type) {
              case 0:
                inO = 1
                outO = 0
                inV = e.in
                outV = e.out
                break
              case 1:
              default:
                inO = 0
                outO = 1
                inV = outV = e.in
            }
            inV.duration(0).ease('ease-out-expo').to(0, 0, 0).opacity(inO).end(function () {
              outV.duration(767).opacity(outO).end(function () {
                e.callback(false)
              })
            })

            setTimeout(() => {
              e.callback(false)
            }, 1200)
          }
        }
        export default {
          config: {
            title: '',
            free: true,
            color: '#000',
            animation: [getAnimate(0), getAnimate(1)]
          }
        }
      </code-highlight>
      <p><small>TransformAnimateEvent 为自定义动画中提供的可用对象</small></p>
      <code-highlight type="js">
        interface TransformAnimateEvent {
          x: number
          y: number
          in: Animate // 切入模块动画类
          out: Animate // 切出模块动画类
          view: Array&lt;HTMLElement> // 视图数组
          width: number
          height: number
          viewport: Array&lt;HTMLElement> // 视窗数组
          modules: Array&lt;Module> // 切换模块数组
          reverse: boolean // 是否反向流动
          direction: number // 流动方向，1前进，-1后退
          backset: number // 流动状态，1前进，-1后退， 0替换
          origin: string | Array&lt;number> // 触发位置
          attach: string | Array&lt;number> // 相轴
          touches: TransformActionOrigin | undefined // 触发 touch 事件
          historyDirection: number // 浏览器前进后退方向
          callback: Function // 结束回掉函数，Promise 模式下不需要用到
        }
        interface TransformActionOrigin {
          x: number,
          y: number
        }
      </code-highlight>
    </div>
    <br />
    <p>数组中的第一个函数为正向动画，第二个函数为逆向动画。如果值为函数，则可通过参数进行动画控制，比如 direction、historyDirection 等。</p>
    <br />
    <p>以下为 Slide 动画的源码实现：</p>
    <div class="doc-code">
      <code-highlight type="js">
        export default (type: number) => {
          return (e: TransformAnimateEvent) => {
            let inX = 0
            let outX = 0
            let inY = 0
            let outY = 0
            const duration = 767

            switch (type) {
              case 0:
                outY = e.height
                inY = -outY
                inX = outX = 0
                break
              case 1:
                inX = e.width
                outX = -inX
                inY = outY = 0
                break
              case 2:
                inY = e.height
                outY = -inY
                inX = outX = 0
                break
              case 3:
                outX = e.width
                inX = -outX
                inY = outY = 0
                break
            }

            if (e.reverse) {
              e.in.duration(0).filter('brightness(0.3)').to(inX * .1, inY * .1, 0).end(() => {
                e.out.duration(duration).ease('ease-out-expo').to(outX, outY, 0).end()
                e.in.duration(duration).ease('ease-out-expo').filter('brightness(1)').to(0, 0, 0).end(() => {
                  e.callback(false)
                })
              })
            } else {
              e.in.duration(0).to(inX, inY, 0).end(() => {
                e.in.duration(duration).ease('ease-out-expo').to(0, 0, 0).end(() => {
                  e.callback(false)
                })
                e.out.duration(duration).ease('ease-out-expo').filter('brightness(0.3)').to(outX * .5, outY * .5, 0).end()
              })
            }

            setTimeout(() => {
              e.callback(false)
            }, duration * 2)
          }
        }
      </code-highlight>
    </div>
    <p>我们可以看到通过使用 TransformAnimateEvent 中提供的信息，即可完成 slide 的四个方位的动画效果。</p>
  </template>

  <template id="background">
    <div class="doc-title">Background</div>
    <p>定义模块是否被允许在后台运行。</p>
    <p><small>value: boolean ｜ 'auto'</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            background: true
          }
        }
      </code-highlight>
    </div>
    <br />
    <p><b>value = false</b>模块切换动画结束后会被立即销毁。</p>
    <hr />
    <p><b>value = true</b>模块不会被销毁（仅当页面 load 成功时）；例外情况是当 timeout 超时时，在启动前会被销毁。</p>
    <hr />
    <p><b>value = 'auto'</b>当设置成自动时模块会进行智能的判断是否销毁，当触发以下几种情况时则会被销毁：</p>
    <ul>
      <li>页面设置了 src，且不同源时</li>
      <li>页面中包含了 object、embed、applet、iframe 对象时</li>
      <li>页面中包含了 video、audio 标签时，且开启智能媒体管理（mediaGuard）时进行自动暂停播放出错时</li>
      <li>页面中存在节点变动操作在 3 秒钟内超过 10 次时</li>
      <li>页面中总的节点操作在后台运行超过 1000 次时</li>
    </ul>

  </template>

  <template id="timeout">
    <div class="doc-title">Timeout</div>
    <p>定义模块的有效时常，单位毫秒。</p>
    <p><small>value: number</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            timeout: 36000
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>页面生命周期的倒计时，页面符合缓存条件或设置为背景运行时，页面在退出并二次进入前会检查过期情况，当检测到模块过期时将会自动进行模块的更新操作。</p>
    <p><small>注：若该值设置为 0 时，则背景运行（background）将不会生效。</small></p>
  </template>

  <template id="limit">
    <div class="doc-title">Limit</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>定义应用最大可缓存在后台的模块数量。</p>
    <p><small>value: number</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            limit: 7
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>默认为 5, 最大值为 100。其表示为应用中所允许的最多同时后台运行的页面，当超过时会根据访问的先后顺序，对最先访问的模块进行销毁，若模块配置了 background = true 时则不受此影响。</p>
    <p><small>注：limit 数量将影响应用运行时的内存占用。</small></p>
  </template>

  <template id="resource">
    <div class="doc-title">Resource</div>
    <p>根据资源类型配置资源 url 数组，在预载入时会根据该配置做预载。</p>
    <p><small>value: number</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        interface ModuleResources {
          script?: Array&lt;string>
          image?: Array&lt;string>
          worker?: Array&lt;string>
          video?: Array&lt;string>
          audio?: Array&lt;string>
          font?: Array&lt;string>
          style?: Array&lt;string>
        }
        export default {
          config: {
            title: '',
            free: true
          },
          resource: {
            script: [
              'http://xxx.com/js/index.js',
            ],
            image: [
              'http://xxx.com/img/background.jpg',
            ]
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>Lath 在模块加载前能够根据 prerender 进行静态资源的预载入（如 html 中的 script、css 标签等），但是对于页面后期通过脚本动态加载的内容（如 css 中的 font 字体，某场景的主题素材等）并不能完成预先的载入，此时可通过 resource 选项将可能发生加载的资源进行预载。</p>
    <p>预载工作并不是立刻执行的，而是在浏览器空闲时按顺序依次载入。</p>
    <p><small>注：非 ModuleResources 中可匹配的未知类型可尝试使用 script 类型进行预载。</small></p>
  </template>

  <template id="prerender">
    <div class="doc-title">Prerender</div>
    <p>进行模块的预加载&预渲染。</p>
    <p>当前模块中如果存在链接到其他模块，且希望能预先载入这些模块时，则可进行设置该属性。页面会在空闲时对该属性中配置的模块列表进行后台的预加载，包括文档中的 css 以及 js 等静态资源的预加载。</p>
    <p><small>value: Array&lt;string></small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            prerender: ['module1', 'module2', 'module3']
          }
        }
      </code-highlight>
    </div>
    <p>预加载模块一般为当前页面的二级模块页面或相关模块页面，是对用户可能会访问这些预载模块页面的一种预判。</p>
    <p>当预载执行时，用户点击到该模块的访问时长将大步消减。</p>
    <p><small>注：prerender 目前在所有浏览器下并无法完成预渲染工作，其当前阶段的能力表述更靠近 “prefetch”，尽管如此，但我们希望在未来能够达到预渲染的能力，因此它依旧保留该选项为 “prerender” 的称呼。</small></p>
  </template>

  <template id="components">
    <div class="doc-title">Components</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>属于同源策略的模块页面可与主页面共享 Web Components。</p>
    <p>Web Components 作为面向未来的组件标准，不仅易于共享也能极大程度上提升页面的体验性能。</p>
    <p><small>value: ((w: Window) => CustomElementConstructor)[]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            ...
          },
          components: [getComponents1, getComponents2, getComponents3]
        }
      </code-highlight>
    </div>
    <p><small>组件例子</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export const getCodeHighlighter = (shadowWindow): CustomElementConstructor => {
          class CodeHighlighter extends shadowWindow.HTMLElement {
            constructor () {
              super()
              const shadowRoot = this.attachShadow({ mode: 'open' })
              shadowRoot.appendChild(tmpl.content.cloneNode(true))
              ...
            }
          }

          return CodeHighlighter as unknown as CustomElementConstructor
        }
      </code-highlight>
    </div>
    <br />
    <p>由于 Web Components 是要共享到各个模块容器内，因此我们封装组件时需要定于组建注册的 window 上下文环境，以便组件能正确的定义在各个容器环境内。</p>
    <p>
      <small>注：模块初始化时将进行调用获取组件函数，同时会将注册上下文 Window 传入，同时返回组件对象 CustomElementConstructor 用于在上下文中进行注册。</small>
    </p>
  </template>

  <template id="mediaGuard">
    <div class="doc-title">MediaGuard</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>该设置开启时，会对同源页面中的视频和音频进行智能的管理，当模块隐藏时则自动暂停正在播放的音视频，反之模块可见时则恢复暂停的音视频。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            mediaGuard: true
          }
        }
      </code-highlight>
    </div>
    <p>一般场景下，自动媒体管控能帮你自动处理媒体状态，若自动处理失败则会触发 background 失效，将会强制终止模块执行。</p>
    <hr />
    <p>不开启此选项，你同样可以通过窗口可见事件进行手动管理 - 请参考 API - Application - Events。</p>
  </template>

  <template id="portal">
    <div class="doc-title">Portal</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>设置为 portal 的模块， 其 [free] 选项也应设置为 true。开启该属性的页面在浏览器支持 portal 特性时，在转场动画结束后会执行 portal 的激活操作，激活后页面会转移至全新的浏览器上下文中运行。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            portal: true
          }
        }
      </code-highlight>
    </div>
    <p>当浏览器不支持 portal 能力时会自动降级为一般容器模式。</p>
  </template>

  <template id="allowHost">
    <div class="doc-title">AllowHost</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>当没有设置 [capture] 时，可通过该配置来过滤掉不需要捕获的 host 地址，反之则会自动进行捕获。</p>
    <p>该配置主要用于防止通过 url 参数拼接的方式使应用不按预期的访问外域网站，以防止被钓鱼页面寄生。</p>
    <p>当 frameworks 模块设置了 [capture] 时，则会忽略该配置。</p>
    <p><small>value: Array&lt;string></small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            allowHost: [
              'aaa.com',
              'bbb.com',
              'ccc.com'
            ]
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>一般模页面中的 A 链接跳转行为会被自动捕获为应用内的新窗口打开，但有时并不希望所有的情况都是如此，因此可通过该选项进行一个有效域的管控，当域不匹配时则不会进行应用内的新窗口打开。</p>
  </template>

  <template id="sandbox">
    <div class="doc-title">Sandbox</div>
    <p>设置容器的沙盒限制。</p>
    <p><small>value: 'allow-same-origin' | 'allow-scripts' | 'allow-forms' | 'allow-modals' | 'allow-orientation-lock' | 'allow-popups' | 'allow-pointer-lock' | 'allow-popups-to-escape-sandbox' | 'allow-presentation' | 'allow-top-navigation' | 'allow-top-navigation-by-user-activation' | 'allow-downloads-without-user-activation' | 'allow-storage-access-by-user-activation' | 'allow-top-navigation-by-user-activation'</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            sandbox: 'allow-same-origin allow-top-navigation allow-modals'
          }
        }
      </code-highlight>
    </div>
    <p>关于 Sandbox 的更多信息，请参照 W3C 定义。</p>
  </template>

  <template id="capture">
    <div class="doc-title">Capture</div>
    <p>可接受一个 url path，当其他页面中存在跳转地址匹配时会被捕获，并按照该模块配置运行新窗口页面。另外也可接受一个函数，resolve 为捕获的 url 信息，当返回 true 时则表示需要捕获该链接并以新窗口打开。
      注意：该能力需要在 [apply] 中开启了 link-in-new-window 时有效（默认开启）</p>
    <p>被捕捉页面需要与主页面保持同源，或被捕捉页接入 Lath，且配置预置参数遂穿模式（tunneling）。</p>
    <p><small>value: string | ((resolve: { path: string; origin: string; host: string; search: string }, url: string) => boolean]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            capture: (resolve) => {
              return resolve.path === '/abc/abc'
            }
          }
        }
      </code-highlight>
    </div>
    <p>capture 返回 true 时则代表某项链接点击被匹配到该模块上，此时不会打开该链接，而是直接映射为该模块的打开，此时链接参数将映射到应用地址栏中。</p>
    <p>capture 的前提是在点击前该模块配置已载入，因此若要 capture 能够生效，需要在点击链接前，在上游模块预先设置 prerender 以便在点击前将该模块配置优先载入。亦或者不采用异步方式载入该模块配置。</p>
  </template>

  <template id="apply">
    <div class="doc-title">Apply&UnApply</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>在同源模块中将自动执行这些预置的应用：</p>
    <ul>
      <li><b>smart-setTimeout</b> 当模块不可见或动画过程中时，所有 setTimeout 会停止执行，相反当模块恢复可见时 setTimeout 也将恢复工作</li>
      <li><b>smart-setInterval</b> 同 smart-setTimeout</li>
      <li><b>link-in-new-window</b> 当页面中有 a链接，或 open 方法打开页面时 会自动进行捕捉拦截，并将页面内容生成新模块的形式并进行加载展示；若设置 target='self' 时则会忽略此逻辑；同时可以设置 preset-effect="预置动画名"，clone-as="新模块名"</li>
      <li><b>tap-highlight</b> 所有 a链接 在点击时会自动添加半透明蒙层高亮提示效果</li>
      <li><b>['tap-highlight', string]</b> 同 tap-highlight，参数为 attr 的匹配，仅匹配元素才增加高亮效果</li>
    </ul>
    <p><small>value: Array&lt;'smart-setTimeout' | 'smart-setInterval' | 'link-in-new-window' | 'tap-highlight' | ['tap-highlight', string]>]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            apply: ['smart-setTimeout', 'link-in-new-window']
          }
        }
      </code-highlight>
    </div>
    <hr />
    <h4>unApply</h4>
    <p>以上选项默认均开启，若不想开启可使用 unApply 配置项。</p>
    <p>unApply 同 Apply 选项相对，它将禁止配置中的预置能力。</p>
  </template>

  <template id="events">
    <div class="doc-title">Events</div>
    <p>定义模块事件监听</p>
    <p><small>value: Array&lt;string></small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true
          },
          // 注意该项同 config 配置为同级配置，不要混淆
          events: {
            transformEnd: () => {
              // ...
            }
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>通过以下行为事件，可在模块生命周期内进行事件的预先干预：</p>
    <ul>
      <li><b>[transformStart: () => void | boolean]</b>  模块转场动画开始， 返回值会停止转场操作</li>
      <li><b>[transformEnd: () => void]</b> 模块动画转场结束</li>
      <li><b>[start: () =>void]</b> 配置启动事件</li>
      <li><b>[load: () =>void]</b> 模块加载事件</li>
      <li><b>[loadError: () =>void]</b> 模块加载错误事件</li>
      <li><b>[preload: () =>void]</b> 模块预载事件</li>
      <li><b>[destroy: () =>void]</b> 模块销毁事件</li>
    </ul>
    <p>需要注意的是 transformStart 可选择返回一个布尔值，当为 true 时，模块转场将被终止。</p>
    <hr />
    <p>注意：模块配置中的事件都是运行在容器外的，因此也需要对逻辑质量（避免产生副作用）和大小（不建议在此处处理复杂逻辑）进行把控。</p>
  </template>

  <template id="preindex">
    <div class="doc-title">Preindex</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>通过链接访问某个模块时，可在之前插入一个前置模块。</p>
    <p>当页面 url 参数锚定到某个模块时，可以通过该配置设置一个前置模块名，此时访问该 url 链接时会优先在锚定模块前插入该 preindex 配置所前置的模块，当点击浏览器返回时不会立刻退出，而是从锚定模块回退转场到该插入的前置模块。</p>
    <p><small>value: string | ((resolve: { path: string; origin: string; host: string; search: string }, url: string) => boolean]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            preindex: 'mainPage'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>当访问链接的锚定模块和 [preindex] 或 [index] 相等时则不会在之前再次插入前置模块。</p>
  </template>

  <template id="notFind">
    <div class="doc-title">NotFind</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>404 模块，所请求的模块页面不存在时会自动路由到该模块，若未配置时则会自动跳转到名为 404 的模块。</p>
    <p><small>value: string</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            notFind: 'fund'
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>404 模块主要用于对应用异常访问时的承接及统计等。</p>
  </template>

  <template id="singleFlow">
    <div class="doc-title">SingleFlow</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>开启历史层级流向控制。</p>
    <p>只允许页面的历史方向往 level 较小的模块回退，当进行返回操作时，返回的历史模块的 level 层级若大于或等于当前模块层级，则直接进行历史跳过，再次进入到前一个历史的回退，直至条件符合。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            singleFlow: true
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>例如：从生成订单模块的到支付订单模块再到我的订单模块，其在完成后进行回退时可选择直接回到订单生成前页面，而无需经过订单完成过程中的各个模块页面。</p>
  </template>

  <template id="singleLock">
    <div class="doc-title">SingleLock</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>当页面回退到程序出口（level === 0 的模块）时，进行返回操作时不会继续回退，而是会开始记录回退次数，并 trigger 给 frameworks 中的 [holdBack] 事件来决定是否允许退出。</p>
    <p>需要注意的是，如果用户访问 lath 容器页时没有进行任何点击跳转操作则将直接退出应用，除非页面设置了[preindex] 配置，且配置有效。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            singleLock: true,
            holdBack: (event) => {
              // 判断是否退出
              return true
            }
          }
        }
      </code-highlight>
    </div>
    <p>如上配置，从其他页面跳转进入到应用时，当点击浏览器返回按钮是并不会退出应用页面，而是会通过 [holdBack] 配置进行判断是否应该被退出，并同时返回用户点击返回按钮的次。</p>
  </template>

  <template id="holdBack">
    <div class="doc-title">HoldBack</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>需配合 [singleLock] 开启时有效，当用户进行返回操作，且页面即将退出时，会通过该函数（如果被阻止，backCount 为点击返回的次数）进行校验，返回 true 时为阻止应用页面退出，否则会允许应用的直接退出。</p>
    <p><small>value: (backCount： number) => boolean]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            singleLock: true,
            holdBack: (event) => {
              // 判断是否退出
              return true
            }
          }
        }
      </code-highlight>
    </div>
    <p>如上配置，从其他页面跳转进入到应用时，当直接点击浏览器返回按钮时，则会直接退回到点击来源页，但是若进入应用后未直接返回而是进行了二级页面跳转，此时再继续点击返回时，多次返回则并不会直接退出应用页面，而是会通过 [holdBack] 配置进行判断是否应该被退出，并同时返回用户点击返回按钮的次。</p>
  </template>

  <template id="transient">
    <div class="doc-title">Transient</div>
    <p>标记该模块为临时模块，在切换到后台时，模块不仅会被销毁，同时模块配置数据也将一并被删除，无特殊情况下一般无需单独配置。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            free: true,
            transient: true
          }
        }
      </code-highlight>
    </div>
    <p>通过新窗口打开（A链接 或 API - pushWindow）的 url 类型模块（即无自定义配置的临时模块），会被自动进行该标记。</p>
    <hr />
    <p>通过 pushWindow 而打开的模块一般都是没有进行模块配置定义的，因此容器将会为其生成一个临时配置，同时在销毁时对该配也一并销毁。若有特殊需求对某模块销毁时希望一并销毁其配置时则可进行该标记。（比如广告模块）</p>
    <h4>DisableTransient</h4>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>DisableTransient 和 Transient 相呼应，可通过此参数来关闭默认的 Transient 行为。</p>
    <p>这是因为在某些情况下，模块不需要定义任何配置（或开发者懒于设置），因此 pushWindow 内容并不非是一个临时模块，因此无需控制被无限枚举的情况，所以可无需自动删除生成的模块配置。</p>
  </template>

  <template id="moduleManifestProcess">
    <div class="doc-title">ModuleManifestProcess</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>当模块载入时，模块配置会先经此函数处理再返回。</p>
    <p><small>value: (config：ModuleManifest)=> ModuleManifest]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            moduleManifestProcess: (manify) => {
              ... 处理
              return newManify
            }
          }
        }
      </code-highlight>
    </div>
    <p>
      由于模块配置是可异步载入的，对于模块中配置的规范性可能不便处理，此时可通过该配置对所有模块配置进行一个统一的重定义。
    </p>
  </template>

  <template id="touchBorder">
    <div class="doc-title">TouchBorder</div>
    <p>设置时模块的边缘触摸事件会得到监听，比如双击模最块顶部执行回到顶部的操作，触摸模块的最左侧可用来执行模块的跟手动画等等。</p>
    <p><small>value: (types: string[], event: TouchEvent) => void</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            touchBorder: (types, event) => {
              ... 处理模块跟手效果/或点击顶部回到顶部效果
            }
          }
        }
      </code-highlight>
    </div>
    <p>事件回调的 types 表示 TouchBorder 事件开始的起始位置，其为一个数组，包含 'top','right','bottom','left','wipe'等 5 个方位的触发位置。</p>
  </template>

  <template id="inject">
    <div class="doc-title">Inject</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>当同源模块时可在页面载入前对页面注入默认的功能和方法，比如提前注入一些 bridge 方法，通用变量，改写一些全局对象等等。</p>
    <p><small>value: (w: Window, m: Module) => void]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            inject: (moduleWindow, module) => {
              ...
            }
          }
        }
      </code-highlight>
    </div>
    <br />
    <p>可在容器运行前对一些基础环境变量和方法做前置操作。</p>
    <hr />
    <p>同时也可以自制插件和解决方案来对特定场景页面定制专属容器。</p>
  </template>

  <template id="render">
    <div class="doc-title">Render</div>
    <p>除了 source 模式外还可以通过 render 方法来渲染元素到对应的节点上，可供系统模块和框架模块使用。</p>
    <p><small>value: (target: HTMLElement) => void]</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            render: (target) => {
              ...
              target.appendChild(...)
              // or ReactDOM.render(&lt;App />, target)
            }
          }
        }
      </code-highlight>
    </div>
    <p>此渲染方案不推荐普通模块使用。</p>
  </template>

  <template id="safeArea">
    <div class="doc-title">SafeArea</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>设定应用的安全边距。</p>
    <p><small>value: string | Array&lt;string></small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            safeArea: ['44px', '0px', '0px', '0px']
          }
        }
      </code-highlight>
    </div>
    <p>值为数字时，分别按顺序表示 顶部、右侧、底部、左侧 的安全边距。</p>
    <p>设置该值后将会在符合同域原则下的模块中注入 CSS 全局变量：--application-safe-area-top、--application-safe-area-right、--application-safe-area-bottom、--application-safe-area-left 四个对应的安全边际值。</p>
    <p>如果需要动态的修改这个值则可以通过发送 “safeAreaChange” 事件来进行更新。</p>
    <p><small>例如:</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        application.trigger('safeAreaChange'，['88px', '0px', '0px', '0px'])
      </code-highlight>
    </div>
    <p>该配置能对刘海屏设备能够进行一个统一的边距控制。</p>
  </template>

  <template id="globalCSSVariables">
    <div class="doc-title">GlobalCSSVariables</div>
    <p><b class="excl">frameworks 类型专有</b></p>
    <p>设定应用的全局 CSS 变量。</p>
    <p><small>value: { [key: string]: string }</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        export default {
          config: {
            title: '',
            globalCSSVariables: {
              '---common-background-color': '#fff',
              '---common-button-color': 'blue',
            }
          }
        }
      </code-highlight>
    </div>
    <p>与 [safeArea] 类似，同样只能在同域原则下有效，与其相比具有能力覆盖的效果。</p>
    <p>如果需要动态的修改或增加这个值则可以通过发送 “globalCSSVariablesChange” 事件来进行更新。</p>
    <p><small>例如:</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        application.trigger('globalCSSVariablesChange'，{
          '---common-button-color': 'red'
        })
      </code-highlight>
    </div>
    <p>当动态变量发生变化时仅对新执行模块有效。</p>
  </template>

  <template id="tunneling">
    <div class="doc-title">Tunneling</div>
    <p><b class="excl">应用的预配置专项</b></p>
    <p>设定应用为“隧穿模式”。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        new Application({
          tunneling: true
        })
      </code-highlight>
    </div>
    <br/>
    <p>若在 A 域下访问 B 域下的模块页面，此时会因同源策略将导致 B 域页面无法实现 [Apply] 新开窗口等能力。因此可通过将 B 页面也同样接入 Lath，并开启 [tunneling] 来解决无法在跨域页面新开窗口的问题。 </p>
    <hr />
    <p>当页面接入 Lath 且开启 [tunneling] 时，页面本身即为一个单独应用，但当该页面在另一个 Lath 应用被访问时，其通过 A链接（即 pushWindow）打开的页面将不在本应用内打开，而是将跳出该跨域页，上升到父级 Lath 应用进行打开。若父级应用也是被访问的 Lath 应用，且也开启了 [tunneling] 则会继续向上“隧穿”。</p>
    <hr />
    <p>注意：该选项是在应用启动时的初始化前配置，请注意和其他章节中的模块配置进行区分。</p>
  </template>

  <template id="zIndex">
    <div class="doc-title">ZIndex</div>
    <p><b class="excl">应用的预配置专项</b></p>
    <p>框架默认起始显示层级。</p>
    <p><small>value: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        new Application({
          zIndex: 1000
        })
      </code-highlight>
    </div>
    <br/>
    <p>当使用 [unuseShadowDom] 禁用 ShadowDom 模式时，你的模块可能会受到未进行 ShadowDom 化的层级元素影响。为避免遮盖可通过设置初始层级来解决这个问题。</p>
    <p>注意：该选项是在应用启动时的初始化前配置，请注意和其他章节中的模块配置进行区分。</p>
  </template>

  <template id="unuseShadowDom">
    <div class="doc-title">UnuseShadowDom</div>
    <p><b class="excl">应用的预配置专项</b></p>
    <p>框架默认不使用 ShadowDom 模式。</p>
    <p>关于 ShadowDom 的更多信息，请查看 W3C 的介绍。</p>
    <p><small>unuseShadowDom: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        new Application({
          unuseShadowDom: true
        })
      </code-highlight>
    </div>
    <br/>
    <p>默认情况下 ShadowDom 模式是自动开启的，若你通过 createApplication 进行预置的模块节点直接移动到 ShadowDom 中会难免的缺失某些依赖时（比如一些全局的脚本操作和动态注入的全局样式等），此时可通过此选项关闭 ShadowDom 来解决此问题。</p>
    <p>注意：该选项是在应用启动时的初始化前配置，请注意和其他章节中的模块配置进行区分。</p>
  </template>

  <!-- API exists -->
  <template id="applicationExists">
    <div class="doc-title">Application.exists</div>
    <p>取得当前页面是否为首次载入的历史序列上。</p>
    <p><small>return: boolean</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        application.start()
        // 还包括任何可读取 application 实力的地方，比如 inject 中
        console.log(application.exists)
      </code-highlight>
    </div>
    <p>例如当你访问链接进去时，首次载入页面将会记录当前历史节点的位置，凡事发生页面活动后都可以检测当前位置是否发生变动，如果该值为 false，则表示历史已经发生变化。</p>
    <p>该方法仅记录初次载入的节点位置，例如你在任何页面发生浏览器刷新都会导致该节点重新标记位置。</p>
  </template>

  <template id="applicationTo">
    <div class="doc-title">Application.to</div>
    <p>转场到指定模块页面</p>
    <div class="doc-code">
      <code-highlight type="js">
        declare interface TransformActionOrigin {
          x: number,
          y: number
        }
        type TransformToOptions = [
          id: string,
          param?: string,
          history?: -1 | 0 | 1,
          touches?: TouchEvent | TransformActionOrigin
        ]
      </code-highlight>
    </div>
    <p><small>Arguments: TransformToOptions</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        application.to('home', '?id=100', 1)
      </code-highlight>
    </div>
    <p>history 为 -1 时不推入或替换历史，为 0 时替换当前历史，为 1 时推入新的历史。</p>
    <p>touches 为发生点击行为的元素点击的 TouchEvent 对象，或直接定义的发生事件 x, y 坐标值的 TransformActionOrigin 对象，用做某些需要根据起始位置而发生的转场动画。</p>
  </template>

  <template id="applicationPushWindow">
    <div class="doc-title">Application.pushWindow</div>
    <p>转场到指定模块或 url 的页面</p>
    <div class="doc-code">
      <code-highlight type="js">
        type pushWindowOtions = [
          url: string,
          title = '',
          preset = 'slide',
          cloneAs?: string,
          touches?: TouchEvent | TransformActionOrigin
        ]
      </code-highlight>
    </div>
    <p><small>Arguments: pushWindowOtions</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        application.pushWindow('home', '首页', 'zoom', 'newHome')
      </code-highlight>
    </div>
    <br />
    <p>同 Application.to 相似，pushWindow 的第一个参数依然可以传入一个模块名，以此来打开一个新的模块页面。</p>
    <hr />
    <p>不同的是 pushWindow 还可以接受一个 url 作为新窗口的参数，就像下面这样：</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.pushWindow('https://yoursite.com/newHome', '首页', 'zoom')
      </code-highlight>
    </div>
    <br />
    <p>可定义参数如下：</p>
    <ul>
      <li><b>cloneAs</b> 表示将该模块重新命名为一个新的副本，此时该新副本不会替换原有模块实例，而是作为一个新命名的模块存在。当页面链接映射到某个模块时，多个映射链接将根据映射模块的配置作为模板分别生成新的模块。</li>
      <li><b>preset</b> 则表示该模块被打开时所执行的内置动画效果。</li>
      <li><b>title</b> 为新页面的 title 名称。</li>
      <li><b>touches</b> 同 Application.to 部分。</li>
      <li><b>url</b> 打开新页面的 url。url 目标页面也将会受到捕捉[capture]逻辑的影响，弱被捕捉则执行打开匹配捕捉的模块 i，否则打开 url 页面。</li>
    </ul>
    <h4>容器内调用</h4>
    <p>注意：pushWindow 是 Application 的方法，因此只能在一些可获得 Application 对象的场景下调用，若直接在容器内使用时，可直参照如下：</p>
    <div class="doc-code">
      <code-highlight type="js">
        // 关于 Types 请参照 API - Types 描述
        type PushWindowOptions = [
          url: string,
          title: string,
          preset: string,
          cloneAs?: string,
          touches?: TouchEvent | TransformActionOrigin
        ]
        parent.postMessage({
          action: 'pushWindow',
          data: ['https://xxx.com/', 'title'] as PushWindowOptions
        })
      </code-highlight>
    </div>
  </template>

  <template id="applicationUpdateSafeArea">
    <div class="doc-title">Application.updateSafeArea</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>更新应用的安全边距</p>
    <p>其初始值请参照模块配置项 [safeArea]</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.updateSafeArea(['48px', 0, '60px', 0])
      </code-highlight>
    </div>
    <br />
    <p>执行更新时，所有生命周期内的模块都将进行实时的更新渲染。</p>
    <hr />
    <p>updateSafeArea 参数为一个数组，同 CSS Margin 一样通过顺时针枚举表达，如以下几种写法均可：</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.updateSafeArea(['48px', 0, '60px', 0])
        application.updateSafeArea(['48px', 0, '60px'])
        application.updateSafeArea(['60px', 0])
        application.updateSafeArea(['48px'])
      </code-highlight>
    </div>
    <br />
    <p>在应用中安全距离并不一定指系统默认刘海屏等，比如有时候框架设计的头部导航区域也希望作为模块的安全避让，当框架交互发生变化时，可通过该方法控制各容器的显示逻辑。</p>
    <hr />
    <h4>非同源页面</h4>
    <p>
      非同源页面不受此控制，但可通过自行建立 postMessage 来同步次操作。另外，在 Application 可通过监听 “safeAreaChange” 事件来监测改变。
    </p>
    <div class="doc-code">
      <code-highlight type="js">
        application.on('safeAreaChange', (data) => {
          console.log(data)
          // module 为跨域页面模块
          // module.view 为跨域页面 iframe
          module.view.postMessage({
            action: 'safeAreaChange',
            data
          }, '*')
        }
      </code-highlight>
    </div>
    <br />
    <p>
      <small>注：在配置中的 events 定义函数中以及通过 Application.get 等方法都可直接获取指定模块对象 Module。</small>
    </p>
  </template>

  <template id="applicationUpdateGlobalCSSVariables">
    <div class="doc-title">Application.updateGlobalCSSVariables</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>更新应用的全局 CSS 变量</p>
    <p>其初始值请参照模块配置项 [globalCSSVariables]</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.updateGlobalCSSVariables({
          '---common-button-color': '#000000',
          '---common-button-width': '100%',
        })
      </code-highlight>
    </div>
    <br />
    <p>执行更新时，所有生命周期内的模块都将进行实时的更新渲染。</p>
    <hr />
    <h4>非同源页面</h4>
    <p>跨域模块页面需要自行处理，处理方法请参考 Application.updateSafeArea 相关介绍。</p>
  </template>

  <template id="applicationStart">
    <div class="doc-title">Application.start</div>
    <p><b class="excl">受同源策略限制</b></p>
    <p>启动应用</p>
    <p>在 start 章节已有描述，该方法没有任何入参，执行次函数即意味着立刻初始化所有配置，并启动应用。</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.start()
      </code-highlight>
    </div>
    <br />
    <p><small>注：这意味着你的应用也可以选择在合适的时机才开始启动。</small></p>
  </template>

  <template id="applicationEvents">
    <div class="doc-title">Application Events</div>
    <p>常用事件监听</p>
    <p>此处为应用事件监听，请注意同模块配置项 [events] 配置进行区分。</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.on('eventName', (...args) => {
          console.log(...args)
        })
      </code-highlight>
    </div>
    <br />
    <p>
      常用事件有：
    </p>
    <ul>
      <li><b>systemDidMount</b> 系统模块初始化已完成</li>
      <li><b>frameworksDidMount</b> 框架模块初始化已完成</li>
      <li><b>globalCSSVariablesChange</b> 全局样式变量更新事件</li>
      <li><b>safeAreaChange</b> 安全边界更新事件</li>
    </ul>
  </template>

  <!-- activeModule -->
  <template id="applicationActiveModule">
    <div class="doc-title">Application.activeModule</div>
    <p>获取当前活动模块对象 Module</p>
    <div class="doc-code">
      <code-highlight type="js">
        console.log(app.activeModule)
      </code-highlight>
    </div>
    <p>例如当前页面为 home 模块，那么执行后将获得 home 模块的 Module 对象。</p>
  </template>

  <template id="applicationPreActiveModule">
    <div class="doc-title">Application.preActiveModule</div>
    <p>获取一个活动模块对象 Module</p>
    <div class="doc-code">
      <code-highlight type="js">
        console.log(app.preActiveModule)
      </code-highlight>
    </div>
    <p>例如现在页面为 home 模块，然后我点击进入了 detail 模块，那么此时执行后将获得 home 模块的 Module 对象。</p>
  </template>

  <template id="applicationGet">
    <div class="doc-title">Application.get</div>
    <p>获得一个指定 id 的模块对象 Module</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.get('home').then((module) => {
          console.log(module)
        }).catch((error) => {
          console.error(error)
        })
      </code-highlight>
    </div>
    <br />
    <p>该方法返回一个 Promise 对象。</p>
    <hr />
    <h4>add</h4>
    <p>通过 add 方法你也可以增加模块配置信息，如下：</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.add('home', {
          config: {
            ...
          }
        })
      </code-highlight>
    </div>
    <br />
    <p>第一个参数为模块名，第二个参数为模块配置 Manifest 描述。</p>
    <p>注：当添加的模块名冲突时，添加不会生效，并返回冲突模块对象。</p>
    <hr />
    <h4>del</h4>
    <p>通过 del 方法你也可以从应用中删除某个模块配置信息，如下：</p>
    <div class="doc-code">
      <code-highlight type="js">
        application.del('home')
      </code-highlight>
    </div>
    <br />
    <p>该方法返回一个 Promise 对象。</p>
    <p>若模块已完成初始化，del 方法同时也将对模块进行销毁回收，并返回操作结果。</p>
  </template>

  <template id="applicationInstall">
    <div class="doc-title">Application.install</div>
    <p>通过 ServiceWorker 安装应用。</p>
    <p>ServiceWorker 能加速你应用的二次访问速度，并在弱网甚至无网环境下可打开。</p>
    <p><small>(options: ServiceWorkerInstallConfig, version: string) => void</small></p>
    <div class="doc-code">
      <code-highlight type="js">
        declare interface ServiceWorkerInstallConfig {
          swPathUrl?: string
          scope?: string
          source?: Array&lt;string>
        }
        const options:ServiceWorkerInstallConfig = {}
        application.install(options)
      </code-highlight>
    </div>
    <br />
    <p>关于 ServiceWorker 请参照 W3C 介绍。</p>
  </template>

</div>

<script>
  const header = document.getElementById('header')
  const page = document.getElementById('page-content')
  const show = () => {
    const id = /id\=(\w+)/.exec(parent.location.search)?.[1]
    const currentEl = document.getElementById(id)
    if (page && currentEl) {
      page.innerHTML = currentEl.innerHTML
    }
    header.style.opacity = '1'
  }
  window.addEventListener('message', (e) => {
    if (e.data.type === 'module-will-show') {
      show()
    } else if (e.data.type === 'module-will-hidden') {
      header.style.opacity = '0'
    }
  })
  show()
</script>
