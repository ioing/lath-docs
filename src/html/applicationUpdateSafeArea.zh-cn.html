
    
<div class="card">
  <h1>Application.updateSafeArea</h1>

<p><small>Application.updateSafeArea</small></p>
<p>更新应用的安全边距（受同源策略限制）。</p>
<hr>
<h3>Types</h3>

<pre><div class="docs-code"><code-highlight type="ts">type ApplicationSafeAreaValue = string | Array&lt;string&gt;
type safeArea = (data: ApplicationSafeAreaValue) =&gt; void
</code-highlight></div></pre>
<hr>
<h3>Details</h3>

<p>其初始值请参照模块配置项 [safeArea]。</p>
<p>updateSafeArea 参数为一个数组，同 CSS Margin 一样通过顺时针枚举表达。</p>
<hr>
<h3>Example</h3>

<pre><div class="docs-code"><code-highlight type="ts">application.updateSafeArea([&#39;48px&#39;, 0, &#39;60px&#39;, 0])
application.updateSafeArea([&#39;48px&#39;, 0, &#39;60px&#39;])
application.updateSafeArea([&#39;60px&#39;, 0])
application.updateSafeArea([&#39;48px&#39;])
</code-highlight></div></pre>
<hr>
<h3>Notes</h3>

<p>在应用中安全距离并不一定指的是系统默认刘海屏，而是由框架程序卡所叠加的安全区域，而当框架交互发生安全边距变化时，则可通过该方法控制各程序卡的显示逻辑。</p>
<p>非同源程序卡页面不受此控制，但可通过自行建立 postMessage 来同步次操作。另外，在 Application 对象上可通过 “on/one” 来监听 “safeAreaChange” 事件。</p>
<pre><div class="docs-code"><code-highlight type="ts">application.on(&#39;safeAreaChange&#39;, (data) =&gt; {
  console.log(data)
  // applet 为跨域页面模块
  // applet.view 为跨域页面 iframe
  applet.view.postMessage({
    action: &#39;safeAreaChange&#39;,
    data
  }, &#39;*&#39;)
}
</code-highlight></div></pre>
<blockquote>
<p>在配置中的 events 定义函数中以及通过 Application.get 等方法都可直接获取目标程序卡对象 Applet。</p>
</blockquote>
</div>
    