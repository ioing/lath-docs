{"version":3,"file":"vendors-node_modules_lath_app_auto_cjs-a3a1c99b_js.js","mappings":";;;;;;;;;;;;;AAAA,cAAc,kDAAkD,gBAAgB,oDAAoD,gBAAgB,+DAA+D,+BAA+B,uDAAuD,kBAAkB,8DAA8D,IAAI,gDAAgD,SAAS,aAAa,IAAI,wEAAwE,IAAI,SAAS,4BAA4B,oFAAoF,6BAAe,oCAAS,KAAK,kIAAkI,cAAc,+CAA+C,uEAAuE,WAAW,EAAE,4BAA4B,UAAU,MAAM,2FAA2F,oWAAoW,WAAW,KAAK,kGAAkG,4EAA4E,uRAAuR,sMAAsM,KAAK,iLAAiL,iCAAiC,2GAA2G,QAAQ,kBAAkB,EAAE;AACh6E;;;;;;;;;;;ACDA,kCAAkC,+CAA+C,WAAW,YAAY,mBAAO,CAAC,yEAAiB,kDAAkD;;;;;;;;;;;;;;;;;;;;;ACAtH;AAC7B;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0CAAM,+BAA+B,0BAA0B,oBAAoB;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO,QAAQ,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,sDAAsD,cAAc;AACpE,uBAAuB,oEAAqB,sBAAsB,eAAe,4DAA4D;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,2CAA2C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2E;;;;;;;;;;;;;;;;AC/M3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,wCAAwC;AACxC,+BAA+B;AAC/B,8BAA8B;AAC9B,gCAAgC;AAChC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gDAAgD;AAChD,8DAA8D;AAC9D,8DAA8D;AAC9D,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAuE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE5B;AAClB","sources":["webpack://lath-docs/./node_modules/compute-scroll-into-view/dist/index.module.js","webpack://lath-docs/./node_modules/lath/app/auto.cjs-a3a1c99b.js","webpack://lath-docs/./node_modules/scroll-polyfill/dist/index.esm.js","webpack://lath-docs/./node_modules/wobble/dist/wobble.es.js"],"sourcesContent":["function t(t){return\"object\"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return(!e||\"hidden\"!==t)&&\"visible\"!==t&&\"clip\"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}export default function(e,i){var o=window,l=i.scrollMode,d=i.block,u=i.inline,h=i.boundary,a=i.skipOverflowHiddenElements,c=\"function\"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError(\"Invalid target\");for(var f=document.scrollingElement||document.documentElement,s=[],p=e;t(p)&&c(p);){if((p=p.parentElement)===f){s.push(p);break}null!=p&&p===document.body&&n(p)&&!n(document.documentElement)||null!=p&&n(p,a)&&s.push(p)}for(var m=o.visualViewport?o.visualViewport.width:innerWidth,g=o.visualViewport?o.visualViewport.height:innerHeight,w=window.scrollX||pageXOffset,v=window.scrollY||pageYOffset,W=e.getBoundingClientRect(),b=W.height,H=W.width,y=W.top,E=W.right,M=W.bottom,V=W.left,x=\"start\"===d||\"nearest\"===d?y:\"end\"===d?M:y+b/2,I=\"center\"===u?V+H/2:\"end\"===u?E:V,C=[],T=0;T<s.length;T++){var k=s[T],B=k.getBoundingClientRect(),D=B.height,O=B.width,R=B.top,X=B.right,Y=B.bottom,L=B.left;if(\"if-needed\"===l&&y>=0&&V>=0&&M<=g&&E<=m&&y>=R&&M<=Y&&V>=L&&E<=X)return C;var S=getComputedStyle(k),j=parseInt(S.borderLeftWidth,10),q=parseInt(S.borderTopWidth,10),z=parseInt(S.borderRightWidth,10),A=parseInt(S.borderBottomWidth,10),F=0,G=0,J=\"offsetWidth\"in k?k.offsetWidth-k.clientWidth-j-z:0,K=\"offsetHeight\"in k?k.offsetHeight-k.clientHeight-q-A:0;if(f===k)F=\"start\"===d?x:\"end\"===d?x-g:\"nearest\"===d?r(v,v+g,g,q,A,v+x,v+x+b,b):x-g/2,G=\"start\"===u?I:\"center\"===u?I-m/2:\"end\"===u?I-m:r(w,w+m,m,j,z,w+I,w+I+H,H),F=Math.max(0,F+v),G=Math.max(0,G+w);else{F=\"start\"===d?x-R-q:\"end\"===d?x-Y+A+K:\"nearest\"===d?r(R,Y,D,q,A+K,x,x+b,b):x-(R+D/2)+K/2,G=\"start\"===u?I-L-j:\"center\"===u?I-(L+O/2)+J/2:\"end\"===u?I-X+z+J:r(L,X,O,j,z+J,I,I+H,H);var N=k.scrollLeft,P=k.scrollTop;x+=P-(F=Math.max(0,Math.min(P+F,k.scrollHeight-D+K))),I+=N-(G=Math.max(0,Math.min(N+G,k.scrollWidth-O+J)))}C.push({el:k,top:F,left:G})}return C}\n//# sourceMappingURL=index.module.js.map\n","function _interopDefaultLegacy(l){return l&&\"object\"==typeof l&&\"default\"in l?l:{default:l}}var install=require(\"scroll-polyfill\"),install__default=_interopDefaultLegacy(install);install__default.default();","import computeScrollIntoView from 'compute-scroll-into-view';\nimport { Spring } from 'wobble';\n\n// @see https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions\r\nconst defaultScrollToOptions = {\r\n    behavior: 'auto',\r\n    left: undefined,\r\n    top: undefined,\r\n};\r\n// @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollInToView\r\nconst defaultScrollIntoViewOptions = {\r\n    behavior: 'auto',\r\n    block: 'start',\r\n    inline: 'nearest',\r\n};\r\nconst doScroll = (target, left, top, behavior) => {\r\n    if (behavior === 'smooth') {\r\n        return smoothScroll(target, left, top);\r\n    }\r\n    // scroll({left: NaN, top: NaN}) => scroll({})\r\n    if (!isNaN(left)) {\r\n        target.scrollLeft = left;\r\n    }\r\n    if (!isNaN(top)) {\r\n        target.scrollTop = top;\r\n    }\r\n};\r\nconst defaultSpringConfig = {\r\n    stiffness: 170,\r\n    damping: 26,\r\n    mass: 1,\r\n    restVelocityThreshold: 0.01,\r\n    restDisplacementThreshold: 0.1,\r\n};\r\nconst spring = (fromValue, toValue, update) => new Promise((r) => new Spring(Object.assign(Object.assign({}, defaultSpringConfig), { fromValue, toValue }))\r\n    .onUpdate((s) => update(s.currentValue))\r\n    .onStop(() => r(void 0))\r\n    .start());\r\nconst smoothScroll = (target, x, y) => {\r\n    const scrollX = () => {\r\n        if (isNaN(x)) {\r\n            return;\r\n        }\r\n        const startX = target.scrollLeft;\r\n        if (startX === x) {\r\n            return;\r\n        }\r\n        return spring(startX, x, (v) => (target.scrollLeft = v));\r\n    };\r\n    const scrollY = () => {\r\n        if (isNaN(y)) {\r\n            return;\r\n        }\r\n        const startY = target.scrollTop;\r\n        if (startY === y) {\r\n            return;\r\n        }\r\n        return spring(startY, y, (v) => (target.scrollTop = v));\r\n    };\r\n    return Promise.all([scrollX(), scrollY()]);\r\n};\r\nconst clampOptions = (target, { left, top }) => {\r\n    const isRootScroller = target === getScrollingElement(target.ownerDocument);\r\n    const clampX = () => {\r\n        if (isNaN(left)) {\r\n            return;\r\n        }\r\n        const scrollportWidth = isRootScroller\r\n            ? target.ownerDocument.documentElement.clientWidth // for IE & Edge\r\n            : target.clientWidth;\r\n        const scrollLeftMax = target.scrollWidth - scrollportWidth;\r\n        return clamp(left, 0, scrollLeftMax);\r\n    };\r\n    const clampY = () => {\r\n        if (isNaN(top)) {\r\n            return;\r\n        }\r\n        const scrollportHeight = isRootScroller\r\n            ? target.ownerDocument.documentElement.clientHeight\r\n            : target.clientHeight;\r\n        const scrollTopMax = target.scrollHeight - scrollportHeight;\r\n        return clamp(top, 0, scrollTopMax);\r\n    };\r\n    return { left: clampX(), top: clampY() };\r\n};\r\nconst clamp = (value, min, max) => {\r\n    return Math.min(Math.max(value, min), max);\r\n};\r\nconst isObject = (val) => {\r\n    const type = typeof val;\r\n    return (type === 'object' && val != null) || type === 'function';\r\n};\r\nconst isWindow = (obj) => obj.window === obj;\r\n// @see: https://codesandbox.io/s/assert-scrolltooptions-y5bm4\r\nconst assertScrollToOptions = (options, target, method) => {\r\n    if (!isObject(options)) {\r\n        const ctor = isWindow(target) ? 'Window' : 'Element';\r\n        throw new TypeError(`Failed to execute '${method}' on '${ctor}': parameter 1 ('options') is not an object.`);\r\n    }\r\n};\r\nconst getScrollingElement = (doc) => {\r\n    // more robust: https://github.com/mathiasbynens/document.scrollingElement\r\n    return doc.scrollingElement || doc.documentElement;\r\n};\r\nconst normTarget = (obj) => isWindow(obj)\r\n    ? getScrollingElement(obj.document)\r\n    : obj;\r\nconst isDetached = (target) => {\r\n    return !(target && target.ownerDocument.documentElement.contains(target));\r\n};\r\nconst createScrollTo = (method, mapOptions) => {\r\n    return (target, options) => {\r\n        if (options == null) {\r\n            return;\r\n        }\r\n        assertScrollToOptions(options, target, method);\r\n        target = normTarget(target);\r\n        if (isDetached(target)) {\r\n            return;\r\n        }\r\n        const opts = Object.assign(Object.assign({}, defaultScrollToOptions), options);\r\n        const finalOpts = mapOptions ? mapOptions(opts, target) : opts;\r\n        const { left, top } = clampOptions(target, finalOpts);\r\n        return doScroll(target, left, top, finalOpts.behavior);\r\n    };\r\n};\r\nconst scrollTo = createScrollTo('scrollTo');\r\nconst scroll = createScrollTo('scroll');\r\nconst scrollBy = createScrollTo('scrollBy', (opts, target) => {\r\n    if (!isNaN(opts.left)) {\r\n        opts.left += target.scrollLeft;\r\n    }\r\n    if (!isNaN(opts.top)) {\r\n        opts.top += target.scrollTop;\r\n    }\r\n    return opts;\r\n});\r\nconst scrollIntoView = (target, options) => {\r\n    target = normTarget(target);\r\n    if (isDetached(target)) {\r\n        return;\r\n    }\r\n    const opts = Object.assign(Object.assign({}, defaultScrollIntoViewOptions), (isObject(options)\r\n        ? options\r\n        : !(options == null || Boolean(options)) && { block: 'end' }));\r\n    return Promise.all(computeScrollIntoView(target, opts).map(({ el, top, left }) => doScroll(el, left, top, opts.behavior))).then(() => { });\r\n};\r\nconst polyfillScrollToOptions = (scope, method) => {\r\n    const nativeMethod = scope[method];\r\n    const isScrollBy = method === 'scrollBy';\r\n    const fallbackMethod = isScrollBy\r\n        ? function (x, y) {\r\n            // scrollBy(NaN, NaN) => no effect\r\n            scrollBy(this, {\r\n                left: isNaN(x) ? undefined : Number(x),\r\n                top: isNaN(y) ? undefined : Number(y),\r\n            });\r\n        }\r\n        : function (x, y) {\r\n            // scroll(NaN, NaN) => scroll(0, 0)\r\n            scrollTo(this, { left: Number(x) || 0, top: Number(y) || 0 });\r\n        };\r\n    scope[method] = function () {\r\n        if (arguments.length === 1) {\r\n            return (isScrollBy ? scrollBy : scrollTo)(this, arguments[0]);\r\n        }\r\n        return (nativeMethod || fallbackMethod).apply(this, arguments);\r\n    };\r\n    return () => {\r\n        scope[method] = nativeMethod;\r\n    };\r\n};\r\nconst polyfillScrollToViewOptions = () => {\r\n    const nativeMethod = Element.prototype.scrollIntoView;\r\n    const fallbackMethod = function (alignToTop) {\r\n        return scrollIntoView(this, alignToTop);\r\n    };\r\n    Element.prototype.scrollIntoView = function () {\r\n        const options = arguments[0];\r\n        if (isObject(options)) {\r\n            return scrollIntoView(this, options);\r\n        }\r\n        return (nativeMethod || fallbackMethod).apply(this, arguments);\r\n    };\r\n    return () => {\r\n        Element.prototype.scrollIntoView = nativeMethod;\r\n    };\r\n};\r\nconst polyfill = ({ force = false } = {}) => {\r\n    if (typeof document !== 'undefined' &&\r\n        (force || !('scrollBehavior' in document.documentElement.style))) {\r\n        const undoFns = [\r\n            polyfillScrollToOptions(window, 'scroll'),\r\n            polyfillScrollToOptions(window, 'scrollBy'),\r\n            polyfillScrollToOptions(window, 'scrollTo'),\r\n            polyfillScrollToOptions(Element.prototype, 'scroll'),\r\n            polyfillScrollToOptions(Element.prototype, 'scrollBy'),\r\n            polyfillScrollToOptions(Element.prototype, 'scrollTo'),\r\n            polyfillScrollToViewOptions(),\r\n        ];\r\n        return () => {\r\n            undoFns.forEach((f) => f());\r\n        };\r\n    }\r\n    return () => { };\r\n};\n\nexport { polyfill as default, scroll, scrollBy, scrollIntoView, scrollTo };\n","/**\r\n *  @license\r\n *  Copyright 2017 Adam Miskiewicz\r\n *\r\n *  Use of this source code is governed by a MIT-style license that can be found\r\n *  in the LICENSE file or at https://opensource.org/licenses/MIT.\r\n */\r\nfunction invariant(condition, message) {\r\n    if (!condition) {\r\n        throw new Error(message);\r\n    }\r\n}\r\nfunction withDefault(maybeValue, defaultValue) {\r\n    return typeof maybeValue !== \"undefined\" && maybeValue !== null\r\n        ? maybeValue\r\n        : defaultValue;\r\n}\n\n/**\r\n *  @license\r\n *  Copyright 2017 Adam Miskiewicz\r\n *\r\n *  Use of this source code is governed by a MIT-style license that can be found\r\n *  in the LICENSE file or at https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Implements a spring physics simulation based on the equations behind\r\n * damped harmonic oscillators (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).\r\n */\r\nclass Spring {\r\n    constructor(config = {}) {\r\n        this._listeners = [];\r\n        this._currentAnimationStep = 0; // current requestAnimationFrame\r\n        this._currentTime = 0; // Current timestamp of animation in ms (real time)\r\n        this._springTime = 0; // Current time along the spring curve in ms (zero-based)\r\n        this._currentValue = 0; // the current value of the spring\r\n        this._currentVelocity = 0; // the current velocity of the spring\r\n        this._isAnimating = false;\r\n        this._oscillationVelocityPairs = [];\r\n        this._config = {\r\n            fromValue: withDefault(config.fromValue, 0),\r\n            toValue: withDefault(config.toValue, 1),\r\n            stiffness: withDefault(config.stiffness, 100),\r\n            damping: withDefault(config.damping, 10),\r\n            mass: withDefault(config.mass, 1),\r\n            initialVelocity: withDefault(config.initialVelocity, 0),\r\n            overshootClamping: withDefault(config.overshootClamping, false),\r\n            allowsOverdamping: withDefault(config.allowsOverdamping, false),\r\n            restVelocityThreshold: withDefault(config.restVelocityThreshold, 0.001),\r\n            restDisplacementThreshold: withDefault(config.restDisplacementThreshold, 0.001)\r\n        };\r\n        this._currentValue = this._config.fromValue;\r\n        this._currentVelocity = this._config.initialVelocity;\r\n    }\r\n    /**\r\n     * If `fromValue` differs from `toValue`, or `initialVelocity` is non-zero,\r\n     * start the simulation and call the `onStart` listeners.\r\n     */\r\n    start() {\r\n        const { fromValue, toValue, initialVelocity } = this._config;\r\n        if (fromValue !== toValue || initialVelocity !== 0) {\r\n            this._reset();\r\n            this._isAnimating = true;\r\n            if (!this._currentAnimationStep) {\r\n                this._notifyListeners(\"onStart\");\r\n                this._currentAnimationStep = requestAnimationFrame((t) => {\r\n                    this._step(Date.now());\r\n                });\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * If a simulation is in progress, stop it and call the `onStop` listeners.\r\n     */\r\n    stop() {\r\n        if (!this._isAnimating) {\r\n            return this;\r\n        }\r\n        this._isAnimating = false;\r\n        this._notifyListeners(\"onStop\");\r\n        if (this._currentAnimationStep) {\r\n            cancelAnimationFrame(this._currentAnimationStep);\r\n            this._currentAnimationStep = 0;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * The spring's current position.\r\n     */\r\n    get currentValue() {\r\n        return this._currentValue;\r\n    }\r\n    /**\r\n     * The spring's current velocity in units / ms.\r\n     */\r\n    get currentVelocity() {\r\n        return this._currentVelocity; // give velocity in units/ms;\r\n    }\r\n    /**\r\n     * If the spring has reached its `toValue`, or if its velocity is below the\r\n     * `restVelocityThreshold`, it is considered at rest. If `stop()` is called\r\n     * during a simulation, both `isAnimating` and `isAtRest` will be false.\r\n     */\r\n    get isAtRest() {\r\n        return this._isSpringAtRest();\r\n    }\r\n    /**\r\n     * Whether or not the spring is currently emitting values.\r\n     *\r\n     * Note: this is distinct from whether or not it is at rest.\r\n     * See also `isAtRest`.\r\n     */\r\n    get isAnimating() {\r\n        return this._isAnimating;\r\n    }\r\n    /**\r\n     * Updates the spring config with the given values.  Values not explicitly\r\n     * supplied will be reused from the existing config.\r\n     */\r\n    updateConfig(updatedConfig) {\r\n        // When we update the spring config, we reset the simulation to ensure the\r\n        // spring always moves the full distance between `fromValue` and `toValue`.\r\n        // To ensure that the simulation behaves correctly if those values aren't\r\n        // being changed in `updatedConfig`, we run the simulation with `_step()`\r\n        // and default `fromValue` and `initialVelocity` to their current values.\r\n        this._advanceSpringToTime(Date.now());\r\n        const baseConfig = {\r\n            fromValue: this._currentValue,\r\n            initialVelocity: this._currentVelocity\r\n        };\r\n        this._config = Object.assign({}, this._config, baseConfig, updatedConfig);\r\n        this._reset();\r\n        return this;\r\n    }\r\n    /**\r\n     * The provided callback will be invoked when the simulation begins.\r\n     */\r\n    onStart(listener) {\r\n        this._listeners.push({ onStart: listener });\r\n        return this;\r\n    }\r\n    /**\r\n     * The provided callback will be invoked on each frame while the simulation is\r\n     * running.\r\n     */\r\n    onUpdate(listener) {\r\n        this._listeners.push({ onUpdate: listener });\r\n        return this;\r\n    }\r\n    /**\r\n     * The provided callback will be invoked when the simulation ends.\r\n     */\r\n    onStop(listener) {\r\n        this._listeners.push({ onStop: listener });\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove a single listener from this spring.\r\n     */\r\n    removeListener(listenerFn) {\r\n        this._listeners = this._listeners.reduce((result, listener) => {\r\n            const foundListenerFn = Object.values(listener).indexOf(listenerFn) !== -1;\r\n            if (!foundListenerFn) {\r\n                result.push(listener);\r\n            }\r\n            return result;\r\n        }, []);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes all listeners from this spring.\r\n     */\r\n    removeAllListeners() {\r\n        this._listeners = [];\r\n        return this;\r\n    }\r\n    _reset() {\r\n        this._currentTime = Date.now();\r\n        this._springTime = 0.0;\r\n        this._currentValue = this._config.fromValue;\r\n        this._currentVelocity = this._config.initialVelocity;\r\n    }\r\n    _notifyListeners(eventName) {\r\n        this._listeners.forEach((listener) => {\r\n            const maybeListenerFn = listener[eventName];\r\n            if (typeof maybeListenerFn === \"function\") {\r\n                maybeListenerFn(this);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * `_step` is the main loop.  While the animation is running, it updates the\r\n     * current state once per frame, and schedules the next frame if the spring is\r\n     * not yet at rest.\r\n     */\r\n    _step(timestamp) {\r\n        this._advanceSpringToTime(timestamp, true);\r\n        // check `_isAnimating`, in case `stop()` got called during\r\n        // `_advanceSpringToTime()`\r\n        if (this._isAnimating) {\r\n            this._currentAnimationStep = requestAnimationFrame((t) => this._step(Date.now()));\r\n        }\r\n    }\r\n    _advanceSpringToTime(timestamp, shouldNotifyListeners = false) {\r\n        // `_advanceSpringToTime` updates `_currentTime` and triggers the listeners.\r\n        // Because of these side effects, it's only safe to call when an animation\r\n        // is already in-progress.\r\n        if (!this._isAnimating) {\r\n            return;\r\n        }\r\n        let deltaTime = timestamp - this._currentTime;\r\n        // If for some reason we lost a lot of frames (e.g. process large payload or\r\n        // stopped in the debugger), we only advance by 4 frames worth of\r\n        // computation and will continue on the next frame. It's better to have it\r\n        // running at slower speed than jumping to the end.\r\n        if (deltaTime > Spring.MAX_DELTA_TIME_MS) {\r\n            deltaTime = Spring.MAX_DELTA_TIME_MS;\r\n        }\r\n        this._springTime += deltaTime;\r\n        const c = this._config.damping;\r\n        const m = this._config.mass;\r\n        const k = this._config.stiffness;\r\n        const fromValue = this._config.fromValue;\r\n        const toValue = this._config.toValue;\r\n        const v0 = -this._config.initialVelocity;\r\n        invariant(m > 0, \"Mass value must be greater than 0\");\r\n        invariant(k > 0, \"Stiffness value must be greater than 0\");\r\n        invariant(c > 0, \"Damping value must be greater than 0\");\r\n        let zeta = c / (2 * Math.sqrt(k * m)); // damping ratio (dimensionless)\r\n        const omega0 = Math.sqrt(k / m) / 1000; // undamped angular frequency of the oscillator (rad/ms)\r\n        const omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay\r\n        const omega2 = omega0 * Math.sqrt(zeta * zeta - 1.0); // frequency of damped oscillation\r\n        const x0 = toValue - fromValue; // initial displacement of the spring at t = 0\r\n        if (zeta > 1 && !this._config.allowsOverdamping) {\r\n            zeta = 1;\r\n        }\r\n        let oscillation = 0.0;\r\n        let velocity = 0.0;\r\n        const t = this._springTime;\r\n        if (zeta < 1) {\r\n            // Under damped\r\n            const envelope = Math.exp(-zeta * omega0 * t);\r\n            oscillation =\r\n                toValue -\r\n                    envelope *\r\n                        ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) +\r\n                            x0 * Math.cos(omega1 * t));\r\n            // This looks crazy -- it's actually just the derivative of the\r\n            // oscillation function\r\n            velocity =\r\n                zeta *\r\n                    omega0 *\r\n                    envelope *\r\n                    (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 +\r\n                        x0 * Math.cos(omega1 * t)) -\r\n                    envelope *\r\n                        (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) -\r\n                            omega1 * x0 * Math.sin(omega1 * t));\r\n        }\r\n        else if (zeta === 1) {\r\n            // Critically damped\r\n            const envelope = Math.exp(-omega0 * t);\r\n            oscillation = toValue - envelope * (x0 + (v0 + omega0 * x0) * t);\r\n            velocity =\r\n                envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));\r\n        }\r\n        else {\r\n            // Overdamped\r\n            const envelope = Math.exp(-zeta * omega0 * t);\r\n            oscillation =\r\n                toValue -\r\n                    envelope *\r\n                        ((v0 + zeta * omega0 * x0) * Math.sinh(omega2 * t) +\r\n                            omega2 * x0 * Math.cosh(omega2 * t)) /\r\n                        omega2;\r\n            velocity =\r\n                envelope *\r\n                    zeta *\r\n                    omega0 *\r\n                    (Math.sinh(omega2 * t) * (v0 + zeta * omega0 * x0) +\r\n                        x0 * omega2 * Math.cosh(omega2 * t)) /\r\n                    omega2 -\r\n                    envelope *\r\n                        (omega2 * Math.cosh(omega2 * t) * (v0 + zeta * omega0 * x0) +\r\n                            omega2 * omega2 * x0 * Math.sinh(omega2 * t)) /\r\n                        omega2;\r\n        }\r\n        this._currentTime = timestamp;\r\n        this._currentValue = oscillation;\r\n        this._currentVelocity = velocity;\r\n        if (!shouldNotifyListeners) {\r\n            return;\r\n        }\r\n        this._notifyListeners(\"onUpdate\");\r\n        if (!this._isAnimating) {\r\n            // a listener might have stopped us in _onUpdate\r\n            return;\r\n        }\r\n        // If the Spring is overshooting (when overshoot clamping is on), or if the\r\n        // spring is at rest (based on the thresholds set in the config), stop the\r\n        // animation.\r\n        if (this._isSpringOvershooting() || this._isSpringAtRest()) {\r\n            if (k !== 0) {\r\n                // Ensure that we end up with a round value\r\n                this._currentValue = toValue;\r\n                this._currentVelocity = 0;\r\n                this._notifyListeners(\"onUpdate\");\r\n            }\r\n            this.stop();\r\n            return;\r\n        }\r\n    }\r\n    _isSpringOvershooting() {\r\n        const { stiffness, fromValue, toValue, overshootClamping } = this._config;\r\n        let isOvershooting = false;\r\n        if (overshootClamping && stiffness !== 0) {\r\n            if (fromValue < toValue) {\r\n                isOvershooting = this._currentValue > toValue;\r\n            }\r\n            else {\r\n                isOvershooting = this._currentValue < toValue;\r\n            }\r\n        }\r\n        return isOvershooting;\r\n    }\r\n    _isSpringAtRest() {\r\n        const { stiffness, toValue, restDisplacementThreshold, restVelocityThreshold } = this._config;\r\n        const isNoVelocity = Math.abs(this._currentVelocity) <= restVelocityThreshold;\r\n        const isNoDisplacement = stiffness !== 0 &&\r\n            Math.abs(toValue - this._currentValue) <= restDisplacementThreshold;\r\n        return isNoDisplacement && isNoVelocity;\r\n    }\r\n}\r\nSpring.MAX_DELTA_TIME_MS = 1 / 60 * 1000 * 4; // advance 4 frames at max\n\nexport { Spring };\n//# sourceMappingURL=wobble.es.js.map\n"],"names":[],"sourceRoot":""}