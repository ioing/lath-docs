(self.webpackChunklath_docs=self.webpackChunklath_docs||[]).push([[985],{2078:n=>{n.exports='\n    \n<div class="card">\n  <h1>FAQ</h1>\n\n<p><strong>Lath 带来了什么？</strong></p>\n<p>它能让你的页面体验更加极致，实现媲美原生 Apps 的效果，比如<a to-applet="docs?id=prerender" clone-as="popDoc">预载二级页面</a>，<a to-applet="docs?id=modality" clone-as="popDoc">Pop Sheet</a> 交互效果，<a to-applet="docs?id=pullToRefresh" clone-as="popDoc">平滑无闪烁下拉刷新</a>，实现无缝的<a to-applet="docs?id=segueEffect" clone-as="popDoc">页面转场效果</a>以及流畅的<a to-applet="docs?id=defaultSlideViewApplets" clone-as="popDoc">页面横滑效果</a>等等诸多实现方案。</p>\n<p>当你要获得这一切时并无需对原有逻辑和框架做出改变，甚至在初始页面的加载时也不会有对页面性能产生阻塞。</p>\n<p>Lath 在窗口管理上有着非常优秀的设计，不仅能自动帮你进行资源回收，还能对页面间的事件进程进行自动管控，用它创建的应用是真正能达到媲美 Native Apps 的 Web App。\n接下来就开始上手吧！</p>\n<hr>\n<p><strong>使用成本如何？</strong></p>\n<p>Lath 是一个容器，因此它对你的 web 程序使用什么框架是没有要求的，甚至你无需修改你的程序逻辑，仅通过一些简单的配置和约定即可完成到 Lath 的改造，例如你可以使用 React、VueJs、等等。</p>\n<hr>\n<p><strong>使用 &lt;define-applet&gt; 声明后滚动事件去哪了？</strong></p>\n<p>每一个 Applet 视图都相当于是一个完整的页面内容，其都应具有自身的滚动容器，因此当使用 &lt;define-applet&gt; 进行声明后，其内部和滚动事件相关的逻辑需要从“body”中移除，修改绑定到自身的 &lt;define-applet&gt; 标签元素上。</p>\n<hr>\n<p><strong>如何引入跨域的页面视图？</strong></p>\n<p>当使用 source 声明 Applet 的视图，若其 src 页面指向为一个跨域页面，则该页面中的被代理类型的能力将会受到限制，若要解决此问题可在引用页面中同样引入 Lath 并开启选项 <a to-applet="docs?id=tunneling" clone-as="popDoc">PresetConfig &gt; tunneling</a> 来解除一些限制。</p>\n<hr>\n<p><strong>Lath 对执行时机有要求吗？</strong></p>\n<p>Lath 作为体验加强容器并非是首屏上所必须的，因此我们建议在首屏加载完成后再执行 createApplication 方法，不阻塞首屏内容呈现。</p>\n<hr>\n<p><strong>Typescript&amp;JSX 警告？</strong></p>\n<p>当使用 Typescript 在 React 环境时，我们需要对容器的标签进行类型定义，否则 ts 将会产生警告，此时在项目中添加该 type.d.ts 文件即可。</p>\n<pre><div class="docs-code"><code-highlight type="ts">// type.d.ts\nimport &#39;lath&#39;\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    &#39;define-applet&#39;: {\n      children: Element\n      &#39;applet-id&#39;: string\n    }\n    &#39;define-application&#39;: {\n      children: Element\n      &#39;default-applet&#39;: string\n    }\n  }\n}\n</code-highlight></div></pre>\n\n</div>\n<div class="card">\n  <h1>相关链接</h1>\n\n<p>一个在 Vue 项目中使用 Lath 进行开发的代码示例[<a href="https://github.com/ioing/lath-vue-example%5D">https://github.com/ioing/lath-vue-example]</a></p>\n</div>\n    '},4950:n=>{n.exports='\n    \n<div class="card">\n  <h1>AllowHost</h1>\n\n<p><small>frameworksAppletConfig &gt; allowHost</small></p>\n<p>当没有设置 [capture] 时，可通过该配置来过滤掉不安全的 host 地址，反之则不受限。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  allowHost?: Array&lt;string&gt;\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>该配置主要用于防止通过 url 参数拼接的方式使应用不按预期的访问外域网站，以防止产生危害。</p>\n<p>当 frameworks 模块设置了 [capture] 时，则会忽略该配置。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      allowHost: [&#39;aaa.com&#39;, &#39;bbb.com&#39;, &#39;ccc.com&#39;],\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>一般程序卡页面中的 A 链接跳转行为会被自动捕获为应用内的新窗口打开，但有时并不希望所有的情况都是如此，因此可通过该选项进行一个有效域的管控，当域不匹配时则不会进行应用内的新窗口打开，而是直接新开浏览器窗口进行访问。</p>\n<blockquote>\n<p>如果你的应用中可能存在由用户输入的可访问地址，那么你很可能需要这项配置，以此来强制新页面以新开浏览器窗口的方式访问。</p>\n</blockquote>\n</div>\n    '},614:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet.color</h1>\n\n<p><small>Applet.color</small></p>\n<p>程序卡的背景色。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type color = string\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>color 来自于 config 中配置，若未配置则返回 frameworks Applet 的 color 设置，若依然未配置或使用继承，则根据浏览器是否为 dark 模式分别返回黑白两色。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\nconsole.log(applet.color)\n</code-highlight></div></pre>\n</div>\n    '},910:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet Events</h1>\n\n<p><small>Applet &gt; on</small></p>\n<p>常用事件监听（on, one, off）。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type ApplicationSafeAreaValue = string | Array&lt;string&gt;\ntype GlobalCSSVariables = { [key: string]: string }\ntype TriggerEventArgsMap = {\n  show: []\n  hide: []\n  willShow: []\n  willHide: []\n  destroy: []\n  pullToRefreshEnd: []\n  pullToRefreshCancel: []\n}\ntype TriggerEventTypes = keyof TriggerEventArgsMap\ntype TriggerEventCallbackArgs&lt;N extends TriggerEventTypes&gt; =\n  TriggerEventArgsMap[N]\ntype TriggerEventCallback&lt;N extends TriggerEventTypes&gt; = (\n  ...args: TriggerEventArgsMap[N]\n) =&gt; void\ntype TriggerEventTypesCallbacks = Record&lt;\n  TriggerEventTypes,\n  TriggerEventCallback&lt;keyof TriggerEventArgsMap&gt;\n&gt;\ntype on = &lt;T extends TriggerEventTypes, F extends TriggerEventCallback&lt;T&gt;&gt;(\n  type: T,\n  fn: F,\n  groupName?: string\n) =&gt; this\ntype off = &lt;T extends TriggerEventTypes, F extends TriggerEventCallback&lt;T&gt;&gt;(\n  type: T,\n  fn: F\n) =&gt; this\ntype one = on\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p><strong>show</strong></p>\n<p>程序卡显示。</p>\n<p><strong>hide</strong></p>\n<p>程序卡消失。</p>\n<p><strong>willShow</strong></p>\n<p>程序卡即将显示。</p>\n<p><strong>willHide</strong></p>\n<p>程序卡即将消失。</p>\n<p><strong>destroy</strong></p>\n<p>程序卡被销毁。</p>\n<p><strong>pullToRefreshEnd</strong></p>\n<p>程序卡下拉刷新结束。</p>\n<p><strong>pullToRefreshCancel</strong></p>\n<p>程序卡下拉刷新取消。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\napplet.on(&#39;willShow&#39;, () =&gt; {\n  //...\n})\n</code-highlight></div></pre>\n</div>\n    '},6283:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet.refresh</h1>\n\n<p><small>Applet.refresh</small></p>\n<p>程序卡的视图对象。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type refresh = () =&gt; Promise&lt;void&gt;\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>平滑页面刷新，返回一个 Promise 对象。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\napplet.refresh()\n</code-highlight></div></pre>\n</div>\n    '},4323:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet.sameOrigin</h1>\n\n<p><small>Applet.sameOrigin</small></p>\n<p>程序卡页面是否同源。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type sameOrigin = boolean\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>由 source.src 所配置的程序卡，若为同源返回 true。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\nconsole.log(applet.sameOrigin)\n</code-highlight></div></pre>\n</div>\n    '},6358:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet.slide</h1>\n\n<p><small>Applet.slide</small></p>\n<p>横滑程序卡的控制对象（类似 Snap 效果）。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface Slide {\n  to: (id: number | string) =&gt; Promise&lt;unknown&gt;\n  index: number\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>“to” 函数能够接受一个序列（对应配置项 defaultSlideViewApplets 中的 Applet 序列）/ Applet id。</p>\n<p>“index” 属性可获取当前 SlideView 上所处于激活状态的程序卡的序列。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\nawait applet.slide.to(&#39;pageA&#39;)\nconsole.log(applet.slide.index)\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>关于它的创建请参照配置项：DefaultSlideViewApplets。</p>\n</div>\n    '},1715:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet.view</h1>\n\n<p><small>Applet.view</small></p>\n<p>程序卡的视图对象。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type view = HTMLElement | HTMLPortalElement | HTMLIFrameElement | null\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>视图的不同的元素类型由 viewType 而决定。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\nconsole.log(applet.view)\n</code-highlight></div></pre>\n</div>\n    '},2681:n=>{n.exports='\n    \n<div class="card">\n  <h1>Applet.viewType</h1>\n\n<p><small>Applet.viewType</small></p>\n<p>程序卡视图的类型。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type viewType = &#39;portal&#39; | &#39;iframe&#39; | &#39;shadow&#39;\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>根据配置项 source 和 render 生成的程序卡分别对应 “iframe” 和 “shadow” 两种类型，而同时配有 source 和 portal 属性的程序卡则为 “portal” 类型。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const applet = await application.get(&#39;home&#39;)\nconsole.log(applet.viewType)\n</code-highlight></div></pre>\n</div>\n    '},5139:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.activityApplet</h1>\n\n<p><small>Application.activityApplet</small></p>\n<p>当前活动的 Applet。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">activityApplet: Applet\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>若当前可视区的程序卡为 home，那么访问该值则会返回 home 程序卡的 Applet 对象。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const application = await createApplication({\n  applets: {\n    ...\n  }\n})\nconsole.log(application.activityApplet)\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>若当前可视区的程序卡为 SlideView 模式中的程序卡，此时返回的值为为 SlideView 视窗的程序卡，而非 SlideView 视图中的子程序卡。</p>\n<blockquote>\n<p>若想获得活动程序卡中的子程序卡可查阅 SlideView 的相关介绍。</p>\n</blockquote>\n</div>\n    '},2950:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application Events</h1>\n\n<p><small>Application &gt; on</small></p>\n<p>常用事件监听（on, one, off）。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type ApplicationSafeAreaValue = string | Array&lt;string&gt;\ntype GlobalCSSVariables = { [key: string]: string }\ntype TriggerEventArgsMap = {\n  safeAreaChange: [ApplicationSafeAreaValue]\n  globalCSSVariablesChange: [GlobalCSSVariables]\n  transformStart: [Applet[]]\n  transformEnd: [Applet[]]\n  systemDidMount: [Applet]\n  frameworksDidMount: [Applet]\n  pullToRefreshReady: []\n  exit: [{ backoutCount: number }]\n  back: [Applet]\n  error: [e: unknown]\n}\ntype TriggerEventTypes = keyof TriggerEventArgsMap\ntype TriggerEventCallbackArgs&lt;N extends TriggerEventTypes&gt; =\n  TriggerEventArgsMap[N]\ntype TriggerEventCallback&lt;N extends TriggerEventTypes&gt; = (\n  ...args: TriggerEventArgsMap[N]\n) =&gt; void\ntype TriggerEventTypesCallbacks = Record&lt;\n  TriggerEventTypes,\n  TriggerEventCallback&lt;keyof TriggerEventArgsMap&gt;\n&gt;\ntype on = &lt;T extends TriggerEventTypes, F extends TriggerEventCallback&lt;T&gt;&gt;(\n  type: T,\n  fn: F,\n  groupName?: string\n) =&gt; this\ntype off = &lt;T extends TriggerEventTypes, F extends TriggerEventCallback&lt;T&gt;&gt;(\n  type: T,\n  fn: F\n) =&gt; this\ntype one = on\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p><strong>safeAreaChange</strong></p>\n<p>可监听安全边距更新，若 updateSafeArea 被调用时通知，返回安全边距对象。</p>\n<p><strong>globalCSSVariablesChange</strong></p>\n<p>可监听全局样式变量更新，若 updateGlobalCSSVariables 被调用时通知，返回更新样式变量对象。</p>\n<p><strong>transformStart</strong></p>\n<p>当发生窗口切换前将通知，返回窗口程序卡数组。</p>\n<p><strong>transformEnd</strong></p>\n<p>当发生窗口切换完成时将通知，返回窗口程序卡数组。</p>\n<p><strong>systemDidMount</strong></p>\n<p>当系统程序卡执行完成时将通知，并返回 System Applet。</p>\n<p><strong>frameworksDidMount</strong></p>\n<p>当框架程序卡执行完成时将通知，并返回 Frameworks Applet。</p>\n<p><strong>pullToRefreshReady</strong></p>\n<p>当配置使用了下拉刷新，且下拉刷新原子能力准备完成时发出通知。</p>\n<p><strong>exit</strong></p>\n<p>当程序触发退出应用时发出通知，返回尝试退出累积次数。</p>\n<p><strong>back</strong></p>\n<p>当程序触发历史返回时通知，返回目标 Applet。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts"> const { application } = await createApplication({\n              applets: {\n                ...\n              }\n            })\n            application.on(&#39;frameworksDidMount&#39;, () =&gt; {\n              //...\n            })\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>Application Events 上的事件使用场景一般不高，比较常用的事件在 Applet Events 上的比较多一些。</p>\n</div>\n    '},1671:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.exists</h1>\n\n<p><small>Application.exists</small></p>\n<p>取得当前页面是否为首次载入的历史序列上。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type exists = boolean\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>当你首次访问链接进入应用时，Lath 会记录你当前历史节点的位置，凡是发生页面活动后都可以检测当前位置是否发生了变动，如果该值为 false，则表示历史已经发生变化，即当前历史非首次进入的历史。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">console.log(application.exists)\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>该方法仅记录初次载入的节点位置，例如你在任何页面发生浏览器刷新都会导致该节点重新标记位置。</p>\n</div>\n    '},2517:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.get</h1>\n\n<p><small>Application.get</small></p>\n<p>获得程序卡对象 Applet。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type get = (id: string) =&gt; Promise&lt;Applet&gt;\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>“id”为要获取的程序卡名。</p>\n<p>其返回为一个 Promise。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const home = await application.get(&#39;home&#39;)\n</code-highlight></div></pre>\n\n</div>\n<div class="card">\n  <h1>Application.del</h1>\n\n<p><small>Application.del</small></p>\n<p>删除一个程序卡对象 Applet。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type del = (id: string) =&gt; Promise&lt;boolean&gt;\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>“id”为要删除的程序卡名。</p>\n<p>其返回为一个 Promise，删除成功你将获得 true。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const isDel = await application.del(&#39;demo&#39;)\n</code-highlight></div></pre>\n\n</div>\n<div class="card">\n  <h1>Application.add</h1>\n\n<p><small>Application.add</small></p>\n<p>增加一个程序卡对象 Applet。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">declare interface AppletManifest {\n  config: AppletConfig\n  resources?: AppletResources\n  components?: ((w: Window) =&gt; CustomElementConstructor)[]\n  events?: Partial&lt;AppletEvents&gt;\n}\ntype add = (id: string, manifest: AppletManifest) =&gt; Applet\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>“id”为要新增的程序卡名。</p>\n<p>其返回为新程序卡对象 Applet。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts"> const newApplet = await application.add(&#39;demo&#39;, {\n              config: {\n                title: &#39;title&#39;,\n                ...\n              }\n            })\n</code-highlight></div></pre>\n</div>\n    '},9384:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.preActivityApplet</h1>\n\n<p><small>Application.preActivityApplet</small></p>\n<p>前一个活动的 Applet。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">preActivityApplet: Applet\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>返回前一个来源的 Applet。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const { application } = await createApplication({\n  applets: {\n    ...\n  }\n})\nconsole.log(application.preActivityApplet)\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>程序卡的获取逻辑与<a href="?id=applicationActivityApplet#docs" preset-effect="slide" clone-as="doc-newWindow-applicationActivityApplet">Application.activeApplet</a>保持一致。</p>\n</div>\n    '},3809:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.PushWindow</h1>\n\n<p><small>Application.pushWindow</small></p>\n<p>转场到指定程序卡或 url 的页面。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">declare interface TransformActionOrigin {\n  x: number\n  y: number\n}\ntype PushWindowOptions = [\n  url: string,\n  title: string,\n  preset: string,\n  cloneAs?: string,\n  touches?: TouchEvent | TransformActionOrigin\n]\ntype pushWindow = (\n  url: string,\n  title = &#39;&#39;,\n  preset = &#39;slide&#39;,\n  cloneAs?: string,\n  touches?: TouchEvent | TransformActionOrigin\n) =&gt; Promise&lt;void&gt;\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>同 <a href="?id=applicationTo#docs" preset-effect="slide" clone-as="doc-newWindow-applicationTo">Application.to</a> 相似，pushWindow 的第一个参数不仅可以传入一个程序卡 id，还可以传入一个页面 URL，以此来打开一个新生成的程序卡页面。</p>\n<p><strong>cloneAs</strong></p>\n<p>定义将该程序卡新克隆副本的名称，此时该克隆副本不会替换原有程序卡实例，而是作为一个新的程序卡独立存在。</p>\n<p><strong>preset</strong></p>\n<p>定义该程序卡被打开时所使用的内置的动画效果，其值为内置动画名。</p>\n<p><strong>title</strong></p>\n<p>定义打开程序卡的 title 标题。</p>\n<p><strong>touches</strong></p>\n<p>同 Application.to 中 touches 的部分。</p>\n<p><strong>url</strong></p>\n<p>打开新页面的 url（目标页面将会受到捕捉[capture]逻辑的影响）。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">application.pushWindow(\n  &#39;http://www.xxxxx.com/index.html&#39;,\n  &#39;首页&#39;,\n  &#39;zoom&#39;,\n  &#39;newHome&#39;\n)\n</code-highlight></div></pre>\n<p>若在 iframe 页面中想要调用该能力时，可使用 postMessage 发送请求。</p>\n<pre><div class="docs-code"><code-highlight type="ts">parent.postMessage({\n  action: &#39;pushWindow&#39;,\n  data: [&#39;https://xxx.com/&#39;, &#39;title&#39;],\n})\n</code-highlight></div></pre>\n</div>\n    '},5481:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.to</h1>\n\n<p><small>Application.to</small></p>\n<p>转场到指定程序卡。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type TransformToOptions = [\n  id: string,\n  param?: string,\n  history?: -1 | 0 | 1,\n  touches?: TouchEvent | TransformActionOrigin\n]\ntype to = (...args: TransformToOptions) =&gt; Promise&lt;void&gt;\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p><strong>id</strong></p>\n<p>跳转到指定 id 的程序卡。</p>\n<p><strong>param</strong></p>\n<p>跳转程序卡所携带的参数（参数字符串）。</p>\n<p><strong>history</strong></p>\n<p>为 -1 时不推入到历史记录，为 0 时替换当前历史记录，为 1 时推入新的历史记录。</p>\n<p><strong>touches</strong></p>\n<p>为发生点击行为的元素点击的 TouchEvent 对象，或直接定义的发生事件 x, y 坐标值的 TransformActionOrigin 对象，用做某些需要根据起始位置而发生的转场动画。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">application.to(&#39;home&#39;, &#39;?id=100&#39;, 1)\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>该函数为一个异步函数，若访问程序卡不存在则会尝试进入 404 程序卡， 并将原有携带参以及通过参数“__notFoundId”将该模块 id，一并传递给 404 程序卡。</p>\n</div>\n    '},9265:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.updateGlobalCSSVariables</h1>\n\n<p><small>Application.updateGlobalCSSVariables</small></p>\n<p>更新应用的全局 CSS 变量（受同源策略限制）。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type ApplicationSafeAreaValue = string | Array&lt;string&gt;\ntype updateSafeArea = (data: ApplicationSafeAreaValue) =&gt; void\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>执行更新时，所有生命周期内的模块都将进行实时的样式变量更新。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">application.updateGlobalCSSVariables({\n  &#39;---common-button-color&#39;: &#39;#000000&#39;,\n  &#39;---common-button-width&#39;: &#39;100%&#39;,\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>跨域模块页面需要自行处理，处理方法请参考 Application.updateSafeArea 相关介绍。</p>\n</div>\n    '},7694:n=>{n.exports='\n    \n<div class="card">\n  <h1>Application.updateSafeArea</h1>\n\n<p><small>Application.updateSafeArea</small></p>\n<p>更新应用的安全边距（受同源策略限制）。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type ApplicationSafeAreaValue = string | Array&lt;string&gt;\ntype safeArea = (data: ApplicationSafeAreaValue) =&gt; void\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>其初始值请参照模块配置项 [safeArea]。</p>\n<p>updateSafeArea 参数为一个数组，同 CSS Margin 一样通过顺时针枚举表达。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">application.updateSafeArea([&#39;48px&#39;, 0, &#39;60px&#39;, 0])\napplication.updateSafeArea([&#39;48px&#39;, 0, &#39;60px&#39;])\napplication.updateSafeArea([&#39;60px&#39;, 0])\napplication.updateSafeArea([&#39;48px&#39;])\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>在应用中安全距离并不一定指的是系统默认刘海屏，而是由框架程序卡所叠加的安全区域，而当框架交互发生安全边距变化时，则可通过该方法控制各程序卡的显示逻辑。</p>\n<p>非同源程序卡页面不受此控制，但可通过自行建立 postMessage 来同步次操作。另外，在 Application 对象上可通过 “on/one” 来监听 “safeAreaChange” 事件。</p>\n<pre><div class="docs-code"><code-highlight type="ts">application.on(&#39;safeAreaChange&#39;, (data) =&gt; {\n  console.log(data)\n  // applet 为跨域页面模块\n  // applet.view 为跨域页面 iframe\n  applet.view.postMessage({\n    action: &#39;safeAreaChange&#39;,\n    data\n  }, &#39;*&#39;)\n}\n</code-highlight></div></pre>\n<blockquote>\n<p>在配置中的 events 定义函数中以及通过 Application.get 等方法都可直接获取目标程序卡对象 Applet。</p>\n</blockquote>\n</div>\n    '},4785:n=>{n.exports='\n    \n<div class="card">\n  <h1>AppletManifestProcess</h1>\n\n<p><small>frameworlksAppletConfig &gt; appletManifestProcess</small></p>\n<p>当程序卡载入时，其配置文件会先经此函数加工后再返回。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  appletManifestProcess?: (config: AppletManifest) =&gt; AppletManifest\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>处理函数将传入当前处理程序卡配置，并接收一个新程序卡配置。</p>\n<p>可通过该配置对所有程序卡配置进行重写，比如设定统一的动画效果或对一些安全选项进行校验。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        appletManifestProcess: (manify) =&gt; {\n          ... 处理\n          return newManify\n        }\n      }\n    }\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>程序卡配置中存在一些复杂选项，比如 inject、components 等，可通过此选项将可复用配置进行统一化管理。</p>\n</div>\n    '},9678:n=>{n.exports='\n    \n<div class="card">\n  <h1>Apply&amp;UnApply</h1>\n\n<p><small>AppletConfig &gt; apply</small></p>\n<p>在同源程序卡中启用可预置的能力。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type AppletApplyMabyeOptions =\n  | &#39;smart-setTimeout&#39;\n  | &#39;proxy-link&#39;\n  | &#39;tap-highlight&#39;\ntype AppletApplyOptions = Array&lt;AppletApplyMabyeOptions&gt;\ntype AppletApplyOptionsParam = {\n  &#39;tap-highlight&#39;?: {\n    selector: string\n  }\n}\ninterface AppletBaseConfig {\n  apply?: AppletApplyOptions\n  applyOptions?: AppletApplyOptionsParam\n  unApply?: AppletApplyOptions\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>apply 预置了以下可用能力：</p>\n<ul>\n<li><strong>smart-setTimeout</strong> 当程序卡窗口不可见时或正处于窗口动画过程中时，所有 setTimeout 会自动暂停执行，直到模块动画停止并可见时自动恢复执行。</li>\n<li><strong>proxy-link</strong> 当程序卡页面中有使用 a 链接或 window.open 方法打开页面时，Lath 容器会自动进行捕捉拦截，并将页面内容生成新的程序卡，之后再进行加载展示。若 A 链接设置 target=&#39;_parent&#39; 或 target=&#39;_top&#39; 时则不会进行捕获，以浏览器新开窗口打开。在 A 链接中还可以设置动画效果和设置克隆为新模块 preset-effect=&quot;预置动画名&quot;，clone-as=&quot;新模块名&quot;</li>\n<li><strong>tap-highlight</strong> 所有 a 链接 在点击时会自动添加半透明蒙层高亮提示效果</li>\n</ul>\n<blockquote>\n<p>在 A 链接上使用 clone-as 属性时，目的是为了让同一程序卡以多个分身打开，比如文章详情程序卡，当其参数不同时可同时以分身打开多篇文章，而不是在同一个实例中更新文章。</p>\n</blockquote>\n<p>以上选项默认均开启，若不想开启可使用 unApply 配置项。</p>\n<p>unApply 同 apply 选项相背，它将禁止配置中的预置能力。</p>\n<p>applyOptions 可针对每项能力增加可用参数，目前可为&quot;tap-highlight&quot;提供高亮选择器&quot;selector&quot;，当点击元素匹配时将增加高亮效果，同时会在元素上新增&quot;tap-highlight&quot;属性，可用作 CSS 样式自定义。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        unApply: [&#39;proxy-link&#39;],\n        applyOptions: {\n          &#39;tap-highlight&#39;: {\n            selector: &#39;.link&#39;,\n          },\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>注意，使用“proxy-link”时不能捕捉通过“location.href”方法实现的跳转行为。</p>\n</div>\n    '},6425:n=>{n.exports='\n    \n<div class="card">\n  <h1>Background</h1>\n\n<p><small>AppletConfig &gt; background</small></p>\n<p>程序卡是否被允许在后台运行。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  background?: boolean | &#39;auto&#39;\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p><strong>value = false</strong></p>\n<p>模块切换动画结束后会被立即销毁。</p>\n<p><strong>value = true</strong></p>\n<p>模块不会被销毁（仅当页面 load 成功时）；例外情况是当 timeout 超时时，在启动前会被销毁。</p>\n<p><strong>value = &#39;auto&#39;</strong></p>\n<p>当设置成自动时模块会进行智能的判断是否销毁，当触发以下几种情况时则会被销毁：</p>\n<ul>\n<li>页面设置了 src，且不同源时</li>\n<li>页面中包含了 object、embed、applet、iframe 对象时</li>\n<li>页面中包含了 video、audio 标签时，且开启智能媒体管理（mediaGuard）时进行自动暂停播放出错时</li>\n<li>页面中存在节点变动操作在 3 秒钟内超过 10 次时</li>\n<li>页面中总的节点操作在后台运行超过 1000 次时</li>\n</ul>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        background: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>若从该程序卡进入 “Pop Sheet&quot; 等 Modality 类型非全屏程序卡时，即便符合销毁条件也将不会执行。</p>\n</div>\n    '},9420:n=>{n.exports='\n    \n<div class="card">\n  <h1>Capture</h1>\n\n<p><small>AppletConfig &gt; capture</small></p>\n<p>捕捉其它程序卡中的跳转链接，若匹配时则跳转至该程序卡。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  capture?:\n    | string\n    | ((\n        resolve: {\n          pathname: string\n          origin: string\n          host: string\n          hash: string\n          href: string\n          search: string\n          port: string\n          searchParams: URLSearchParams\n        },\n        url: string\n      ) =&gt; boolean)\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>capture 可接受一个“url path”，或一个捕捉函数，当其它程序卡中进行跳转行为时则可受到该捕获。</p>\n<p>捕捉函数返回 true 时，则代表跳转链接匹配，链接目标将由该程序卡替代。</p>\n<p>在捕捉后，如若跳转链接携带参数，将会把携带参数一并传与捕获者程序卡。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        capture: (resolve) =&gt; {\n          return resolve.path === &#39;/abc/abc&#39;\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>该程序卡是否被提前载入是捕获程序是否工作的重要前提，因此为确保该捕获者程序卡已经被提前依赖加载，则需要在之前程序卡配置选项[prerender]中包含对该依赖程序卡的提前载入。</p>\n<p>当开启此选项时，所有可被捕获的链接跳转行为都将交由该选项决定是否在应用内打开新窗，这意味着你的规则需要严谨的保障应用的安全性。</p>\n<p>若 frameworks 程序卡开启此选项时，所有未设置该选项的程序卡将默认由 frameworks 程序卡代为处理，同时需要注意的是配置项[allowHost]将失效，因为 capture 将优先代为处理。</p>\n<blockquote>\n<p>仅当前程序卡在 [apply] 中开启了 proxy-link 时，捕获者程序卡才能正常捕获，否则不会进入捕获逻辑，但该选项是默认开启，除非你将其关闭。</p>\n</blockquote>\n</div>\n    '},2550:n=>{n.exports='\n    \n<div class="card">\n  <h1>Color</h1>\n\n<p><small>AppletConfig &gt; color</small></p>\n<p>定义程序卡的初始窗口背景色。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  color?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>默认背景色可以在程序卡未加载完成时呈现良好的视觉过渡。</p>\n<p>默认值会根据浏览器是否为“Dark 模式”来自动填充黑色/白色。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        color: &#39;#000&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>请选用合适的背景色来填充程序卡窗口，以确保视觉效果的连贯性。</p>\n<blockquote>\n<p>当背景色与程序卡内容不一致时，用户很有可能见到一个闪烁。</p>\n</blockquote>\n</div>\n    '},3527:n=>{n.exports='\n    \n<div class="card">\n  <h1>Components</h1>\n\n<p><small>AppletManifest &gt; components</small></p>\n<p>属于同源的程序卡页面可与主程序卡页面共享 Web Components。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletManifest {\n  components?: ((w: Window) =&gt; CustomElementConstructor)[]\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>Web Components 作为面向未来的组件标准，不仅易于共享也能极大程度上提升页面的体验性能。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">export const getCodeHighlighter = (shadowWindow): CustomElementConstructor =&gt; {\n  class CodeHighlighter extends shadowWindow.HTMLElement {\n    constructor () {\n      super()\n      const shadowRoot = this.attachShadow({ mode: &#39;open&#39; })\n      shadowRoot.appendChild(tmpl.content.cloneNode(true))\n      ...\n    }\n  }\n\n  return CodeHighlighter as unknown as CustomElementConstructor\n}\ncreateApplication({\n  applets: {\n    home: {\n      config: {\n        title: &#39;Home Page&#39;\n      },\n      components: [getCodeHighlighter]\n    }\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>由于 Web Components 是要共享到各个程序卡容器内，因此我们封装组件时需要将组件注册到该程序卡的 window 变量中。</p>\n</div>\n    '},758:n=>{n.exports='\n    \n<div class="card">\n  <h1>Custom Effect</h1>\n\n<p><small>AppletConfig &gt; animation</small></p>\n<p>自定义程序卡窗口动画。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type AnimationFunction = (\n  e: TransformAnimateEvent\n) =&gt; undefined | Promise&lt;boolean&gt;\ntype AnimationPrestType =\n  | &#39;inherit&#39;\n  | &#39;fade&#39;\n  | &#39;zoom&#39;\n  | &#39;pop-sheet&#39;\n  | &#39;flip&#39;\n  | &#39;flip-left&#39;\n  | &#39;flip-down&#39;\n  | &#39;flip-right&#39;\n  | &#39;flip-up&#39;\n  | &#39;slide&#39;\n  | &#39;slide-left&#39;\n  | &#39;slide-right&#39;\n  | &#39;slide-up&#39;\n  | &#39;slide-down&#39;\ntype AnimationConfig =\n  | AnimationPrestType\n  | boolean\n  | Array&lt;AnimationPrestType&gt;\n  | [AnimationFunction, AnimationFunction]\ninterface AppletBaseConfig {\n  animation?: AnimationConfig\n}\n</code-highlight></div></pre>\n<p>TransformAnimateEvent 为自定义动画中提供的可用对象。</p>\n<pre><div class="docs-code"><code-highlight type="ts">interface TransformActionOrigin {\n  x: number\n  y: number\n}\ninterface TransformAnimateEvent {\n  x: number\n  y: number\n  in: Animate\n  out: Animate\n  view: Array&lt;HTMLElement&gt;\n  width: number\n  height: number\n  viewport: Array&lt;HTMLElement&gt;\n  applets: Array&lt;Applet&gt;\n  reverse: boolean\n  direction: number\n  backset: number\n  origin: string | Array&lt;number&gt;\n  attach: string | Array&lt;number&gt;\n  touches: TransformActionOrigin | undefined\n  historyDirection: number\n  callback: (stillness: boolean) =&gt; void\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>数组中的第一个函数为正向动画，第二个函数为逆向动画。如果值为函数，则可通过参数进行动画控制，比如 direction、historyDirection 等。</p>\n<p>程序卡层级关系还将反应在转场动画的效果上，从小到大为正向动画，反之从大到小时为逆向动画。</p>\n<p>当历史回退到层级为 0 的程序卡时，会触发 singleLock 事件，具体可查看 [singleLock] 配置中的相关描述。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">const getAnimate = (type: number) =&gt; {\n  return (e: TransformAnimateEvent) =&gt; {\n    let inO: number, outO: number, inV: Animate, outV: Animate\n    switch (type) {\n      case 0:\n        inO = 1\n        outO = 0\n        inV = e.in\n        outV = e.out\n        break\n      case 1:\n      default:\n        inO = 0\n        outO = 1\n        inV = outV = e.in\n    }\n    inV\n      .duration(0)\n      .ease(&#39;ease-out-expo&#39;)\n      .to(0, 0, 0)\n      .opacity(inO)\n      .end(function () {\n        outV\n          .duration(767)\n          .opacity(outO)\n          .end(function () {\n            e.callback(false)\n          })\n      })\n    return undefined\n  }\n}\ncreateApplication({\n  applets: {\n    home: {\n      config: {\n        animation: [getAnimate(0), getAnimate(1)],\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<p>我们可以看到通过使用 TransformAnimateEvent 中提供的信息，即可完成 fade 的前进和后退动画效果。</p>\n</div>\n    '},6534:n=>{n.exports='\n    \n<div class="card">\n  <h1>DefaultSlideViewApplets</h1>\n\n<p><small>AppletConfig &gt; defaultSlideViewApplets</small></p>\n<p>Snap 切换效果的程序坞，我们称之为 SlideView。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type SlideViewApplets = Array&lt;{\n  id: string\n  activate: &#39;lazy&#39; | &#39;instant&#39; | &#39;passive&#39;\n}&gt;\ninterface AppletBaseConfig {\n  defaultSlideViewApplets?: SlideViewApplets\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>“id”表示要被加载的程序卡名</p>\n<p>“activate”表示程序卡的激活类型，共分为以下三种：</p>\n<ul>\n<li>lazy: 在浏览器空闲时加载 Applet 页面内容。</li>\n<li>instant: 即刻加载 Applet 页面内容。</li>\n<li>passive: 在被激活时加载 Applet 页面内容。</li>\n</ul>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        defaultSlideViewApplets: [\n          {\n            id: &#39;appletA&#39;,\n            activate: &#39;instant&#39;,\n          },\n          {\n            id: &#39;appletB&#39;,\n            activate: &#39;lazy&#39;,\n          },\n        ],\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>设定 defaultSlideViewApplets 的程序卡将不再具有自身的视图（frameworks Applet 除外），而是其中嵌套了其它的程序卡视图，因此该配置与[source]相冲突，不应同时设置。</p>\n<blockquote>\n<p>另外使用“API-Applet.slide.to”可使程序坞滑动到到指定程序卡位置。</p>\n</blockquote>\n\n</div>\n<div class="card">\n  <h1>OpenSlideViewLeftHolder</h1>\n\n<p><small>AppletConfig &gt; openSlideViewLeftHolder</small></p>\n<p>开启后，在 SlideView 效果下（defaultSlideViewApplets 配置时），最左侧边缘滑动时会允许退出应用。</p>\n<blockquote>\n<p>该配置主要用于解除在首条历史记录下的退出受阻，若浏览历史记录大于 1 时则大多情况下不存在边缘滑动受阻的情况，若不开启则，在 ios 设备中可能出现边缘滑动时仅会触发边缘弹性，而不会回退到上一级。</p>\n</blockquote>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  openSlideViewLeftHolder?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>该值默认为 false。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        defaultSlideViewApplets: [\n          {\n            id: &#39;appletA&#39;,\n            activate: &#39;instant&#39;,\n          },\n          {\n            id: &#39;appletB&#39;,\n            activate: &#39;lazy&#39;,\n          },\n        ],\n        openSlideViewLeftHolder: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>开启该选项后需要注意程序卡左侧边缘将产生 20px 的无反馈区域，开发时应注意预留该安全操作距离。</p>\n</div>\n    '},1714:n=>{n.exports='\n    \n<div class="card">\n  <h1>Events</h1>\n\n<p><small>AppletManifest &gt; events</small></p>\n<p>注册程序卡的事件回调。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">declare interface AppletEvents {\n  transformStart: (applet: Applet) =&gt; undefined | &#39;break&#39;\n  transformEnd: (applet: Applet) =&gt; void\n  boot: (applet: Applet) =&gt; void\n  load: (applet: Applet) =&gt; void\n  loadError: (applet: Applet) =&gt; void\n  preload: (applet: Applet) =&gt; void\n  destroy: (applet: Applet) =&gt; void\n}\ndeclare interface AppletManifest {\n  events?: Partial&lt;AppletEvents&gt;\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>在程序卡中注册生命周期中的事件回调函数。</p>\n<ul>\n<li><strong>transformStart</strong> 程序卡转场动画开始事件。需要注意的是 transformStart 可选择返回一个字符串‘break’，此时模块转场将被终止执行。</li>\n<li><strong>transformEnd</strong> 程序卡转场动画结束事件。</li>\n<li><strong>boot</strong> 程序卡启动事件（每个生命周期内仅一次）。</li>\n<li><strong>load</strong> source 类型程序卡的源代码加载完成事件。</li>\n<li><strong>loadError</strong> source 类型程序卡的源代码加载错误事件。</li>\n<li><strong>preload</strong> 程序卡预加载完事件。</li>\n<li><strong>destroy</strong> 程序卡被销毁事件。</li>\n</ul>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        title: &#39;home&#39;,\n      },\n      events: {\n        transformEnd: (applet) =&gt; {\n          // ...\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>在程序卡注册事件中仅提供必要的事件，如需更多事件则可以使用 Applet 对象上的监听函数，请参照 API - Application Events。</p>\n<blockquote>\n<p>程序卡配置中的事件都是运行在程序卡容器外的，当程序卡销毁时配置中的环境变量并不会随之消失，因此必须对配置文件中的逻辑质量负责，避免产生副作用，并且合理控制逻辑大小（不建议在此处处理复杂逻辑）。</p>\n</blockquote>\n</div>\n    '},5066:n=>{n.exports='\n    \n<div class="card">\n  <h1>Free</h1>\n\n<p><small>AppletConfig &gt; free</small></p>\n<p>定义程序卡的窗口展示类型。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  free?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>free 等于 true 时，程序卡以“全屏模式”运行，即不受框架程序卡（Applets[id = frameworks]）的约束。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        free: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>假设 frameworks 程序卡是一个带有 tabBar 功能的模块，此时程序卡将直接覆盖整个框架程序卡运行，反之程序卡则会在框架程序卡之内运行（即表现为 tabBar 覆盖在程序卡之上）。</p>\n</div>\n    '},6229:n=>{n.exports='\n    \n<div class="card">\n  <h1>GlobalCSSVariables</h1>\n\n<p><small>FrameworksAppletConfig &gt; globalCSSVariables</small></p>\n<p>设定应用的全局 CSS 变量。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type GlobalCSSVariables = { [key: string]: string }\ninterface AppletBaseConfig {\n  globalCSSVariables?: GlobalCSSVariables | (() =&gt; GlobalCSSVariables)\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>与 [safeArea] 相似，同样只能在同域程序卡页面下生效。</p>\n<p>如果需要动态的修改或增加这个值则可以通过 “API-updateGlobalCSSVariables” 事件来进行更新</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        globalCSSVariables: {\n          &#39;--main-color&#39;: &#39;#fff&#39;,\n          &#39;--title-font-size&#39;: &#39;28px&#39;,\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>配合 “API-updateGlobalCSSVariables” 使用，可创造出丝滑的主题切换效果。</p>\n</div>\n    '},9076:n=>{n.exports='\n    \n<div class="card">\n  <h1>HoldBack</h1>\n\n<p><small>FrameworksAppletConfig &gt; holdBack</small></p>\n<p>阻止主程序退出。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface FrameworksAppletConfig {\n  holdBack?: (backoutCount: number) =&gt; boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>需配合 [singleLock] 开启时有效，当用户进行返回操作，且页面即将退出时，会通过该函数（如果被阻止，backCount 为点击返回的次数）进行校验，返回 true 时为阻止应用页面退出，否则会允许应用的直接退出。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        singleLock: true,\n        holdBack: (event) =&gt; {\n          // 判断是否退出\n          return true\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>如上配置，从其它页面跳转进入到应用时，当点击浏览器返回按钮时并不会退出应用页面，而是会通过 Frameworks Applet 中的 [holdBack] 配置进行判断是否应该被退出，并同时返回用户点击返回按钮的次。</p>\n</div>\n    '},8314:n=>{n.exports='\n    \n<div class="card">\n  <h1>Index</h1>\n\n<p><small>FrameworksAppletConfig &gt; index</small></p>\n<p>定义应用的默认入口的程序卡。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface FrameworksAppletConfig {\n  index?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>启动 Lath 应用时首先会先启动 frameworks 程序卡，然后根据“index”配置启动首页程序卡。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        index: &#39;home&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>当应用启动时将首先初始化名称为“home”的程序卡。</p>\n</div>\n    '},5091:n=>{n.exports='\n    \n<div class="card">\n  <h1>Inject</h1>\n\n<p><small>AppletConfig &gt; inject</small></p>\n<p>当为同源程序卡页面时，可在程序卡页面载入前对程序卡页面内注入设定的全局变量与方法，比如注入一些“jsBridge”、通用变量或者改写全局对象等。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  inject?: (w: Window, m: Applet) =&gt; void\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>比如程序卡中的链接跳转是通过“jsBridge”进行的，因此 Lath 并无法自动捕捉，因此现在你想要改写该逻辑，那么现在你则可以通过该选项来进行对其改写。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        inject: (appletWindow, applet) =&gt; {\n          appletWindow.open = (url) =&gt; {\n            return applet.application.pushWindow(url).catch(() =&gt; {\n              window.open(url)\n            })\n          }\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>需要注意的是 inject 选项受同域限制，因此在跨域场景下无法使用。</p>\n<p>inject 是一个强大的能力，你可以基于此开发出不可思议的能力。</p>\n</div>\n    '},9041:n=>{n.exports='\n    \n<div class="card">\n  <h1>Level</h1>\n\n<p><small>AppletConfig &gt; level</small></p>\n<p>程序卡视图窗口显示层级。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  level?: number\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>一般首屏程序卡的层级为 0，根据访问深度而逐级增大。</p>\n<p>程序卡层级关系还将反应在转场动画的效果上，从小到大为正向动画，反之从大到小时为逆向动画。</p>\n<p>当历史回退到层级为 0 的程序卡时，会触发 singleLock 事件，具体可查看 [singleLock] 配置中的相关描述。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        level: 1,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>若跳转的两个模块是为同层级模块，则转场动画效果会被自动关闭。</p>\n<blockquote>\n<p>为什么同级模块动画关闭？：同级模块动画关闭主要场景是用于 tab 切换，一般 tab 切换时不需要一个窗口动画效果，但是从其它层级的窗口切换过来时可能又是需要动画效果的。</p>\n</blockquote>\n</div>\n    '},571:n=>{n.exports='\n    \n<div class="card">\n  <h1>Limit</h1>\n\n<p><small>frameworksAppletConfig &gt; limit</small></p>\n<p>定义应用最大可缓存在后台的程序卡数量。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  limit?: number\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>默认为 5, 最大值为 100。其表示为应用中所允许的最多可同时缓存在后台的程序卡，当超过时会根据访问的顺序，对先访问的模块进行依次销毁，若模块配置了背景运行(background = true)时则不受此规则的影响。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        limit: 10,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>limit 数量将影响应用运行时的内存占用，一般建议在 5-20。</p>\n</div>\n    '},9790:n=>{n.exports='\n    \n<div class="card">\n  <h1>MainScrollId</h1>\n\n<p><small>AppletConfig &gt; mainScrollId</small></p>\n<p>指定 Applet 的主滚动容器，其与 [tapStatusBarToScrollToTop] 和 [pullToRefresh] 能够联合使用。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  mainScrollId?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>如果没有指定主滚动容器，则默认 &lt;define-applet&gt; 元素为主滚动。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        mainScrollId: &#39;root&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>注意指定的滚动容器“id”不可存在于 ShadowDom 中。</p>\n</div>\n    '},3367:n=>{n.exports='\n    \n<div class="card">\n  <h1>MediaGuard</h1>\n\n<p><small>AppletConfig &gt; mediaGuard</small></p>\n<p>该设置开启时，会对同源程序卡页面中的视频和音频进行智能的管控，当模块隐藏时则自动暂停正在播放的音/视频，反之模块可见时则恢复暂停的音/视频。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  mediaGuard?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>一般场景下，自动媒体管控能帮你自动处理媒体状态，若自动处理失败则会强制销毁程序卡，背景运行(background=true)除外。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        mediaGuard: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>不开启此选项，你同样可以通过窗口可见事件进行手动管理 - 请参考 API - Application - Events。</p>\n</div>\n    '},8887:n=>{n.exports='\n    \n<div class="card">\n  <h1>Modality</h1>\n\n<p><small>AppletConfig &gt; modality</small></p>\n<p>程序卡是否以模态框形式展示。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type ModalityType = &#39;paper&#39; | &#39;sheet&#39; | &#39;overlay&#39;\ninterface AppletBaseConfig {\n  modality?: ModalityType\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p><strong>sheet</strong> 一种从底部弹出的窗口效果。</p>\n<p><strong>paper</strong> 一种从点击区块眼神放大的窗口效果。</p>\n<p><strong>overlay</strong> 一种从底部渐变弹出的弹窗效果。</p>\n<p>类型在 config 中还提供有分别的一个自定义选项 <strong>SheetOptions</strong>，PaperOptions 和 OverlayOptions 为 SheetOptions 的子集，可使用选项有所限制。</p>\n<pre><div class="docs-code"><code-highlight type="ts">type ModalityType = &#39;paper&#39; | &#39;sheet&#39; | &#39;overlay&#39;\ntype SheetOptions = {\n  top?: string\n  miniCardHeight?: number | string\n  maskOpacity?: number\n  blockedHolderWidth?: number | string\n  maskClosable?: boolean\n  noHandlebar?: boolean\n  backdropColor?: string\n  stillBackdrop?: boolean\n  swipeClosable?: boolean\n  borderRadius?: number | string\n}\ntype PaperOptions = {\n  clipTop?: string\n  maskOpacity?: number\n  swipeClosable?: boolean\n}\ntype OverlayOptions = {\n  maskOpacity?: number\n  swipeClosable?: boolean\n}\ninterface AppletBaseConfig {\n  modality?: ModalityType\n  sheetOptions?: SheetOptions\n}\n</code-highlight></div></pre>\n<ul>\n<li><strong>top</strong>: 视图顶部距离窗口顶部的边距离距离，支持 CSS 单位。</li>\n<li><strong>miniCardHeight</strong>: 两段式卡片，默认呈现最小尺寸窗口，在小卡呈现时背景内容不会发生缩放效果，直到向上滑打开全部。</li>\n<li><strong>maskOpacity</strong>: 背景黑色蒙层的不透明度，默认为 0.3。</li>\n<li><strong>blockedHolderWidth</strong>: 左侧手指边缘滑动的安全边距（边距大小会覆盖可交互区域），边界值决定了左侧滑动关闭的灵敏度。</li>\n<li><strong>maskClosable</strong>: 点击背景蒙层是否允许关闭窗口，默认为关闭。</li>\n<li><strong>noHandlebar</strong>: 不展示默认的滑动控制手柄，可能你需要在内部视图中重新定义该外观。</li>\n<li><strong>backdropColor</strong>: 当背景程序卡缩放时所呈现的衬底颜色。</li>\n<li><strong>swipeClose</strong>: 手指从中间横向滑动时可操作卡片关闭。</li>\n</ul>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    pageA: {\n      config: {\n        modality: &#39;sheet&#39;\n        sheetOptions: {\n          top: &#39;10%&#39;,\n          miniCardHeight: &#39;30vh&#39;,\n          maskOpacity: 0.5,\n          blockedHolderWidth: 20,\n          maskClosable: true\n        }\n      }\n    }\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>注意 sheetOptions 选项是 modality 选项为 &#39;sheet&#39; 时的进一步特性描述，需配合使用，单独使用时无效。</p>\n</div>\n    '},6566:n=>{n.exports='\n    \n<div class="card">\n  <h1>UnusedShadowDom</h1>\n\n<p><small>PresetConfig &gt; noShadowDom</small></p>\n<p>框架是否使用 ShadowDom 模式。（应用启动前的预配置项）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface PresetConfig {\n  noShadowDom?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<blockquote>\n<p>关于 ShadowDom 的更多信息，请查看 W3C 的介绍。</p>\n</blockquote>\n<p>若你通过 createApplication 指定“index”的模式启动应用时，进行预置的程序卡节点会被直接移动到 ShadowDom 中，此时会造成存在节点外的样式及依赖缺失（比如一些依赖的脚本事件绑定元素和动态注入的全局样式等）。</p>\n<p>默认情况下 ShadowDom 模式已经时关闭的，你无需设定改选项，如果你不存在上述问题，且希切片的程序卡之间不会产生一些干扰，则可以关闭改选项，此时同页面中的切片产生的程序卡则互相之间产生作用域。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  tunneling: true,\n  applets: {\n    ...\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>极少情况下会使用到该配置，当然如果你能使用 &lt;define-applet&gt; 来代替将会是更好的选择。</p>\n</div>\n    '},3584:n=>{n.exports='\n    \n<div class="card">\n  <h1>NotFound</h1>\n\n<p><small>FrameworksAppletConfig &gt; notFound</small></p>\n<p>404 程序卡。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface FrameworksAppletConfig {\n  notFound?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>若所请求的程序卡页面不存在时，则自动路由到该程序卡，若未配置时则会自动跳转到“id”为“404”的程序卡。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        notFound: &#39;home&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>404 模块主要用于对应用异常访问时的承接及统计等。</p>\n</div>\n    '},4631:n=>{n.exports='\n    \n<div class="card">\n  <h1>OpenSlideViewLeftHolder</h1>\n\n<p><small>AppletConfig &gt; openSlideViewLeftHolder</small></p>\n<p>开启后，在 SlideView 效果下（defaultSlideViewApplets 配置时），最左侧边缘滑动时会允许退出应用。</p>\n<blockquote>\n<p>该配置主要用于解除在首条历史记录下的退出受阻，若浏览历史记录大于 1 时则大多情况下不存在边缘滑动受阻的情况，若不开启则，在 ios 设备中可能出现边缘滑动时仅会触发边缘弹性，而不会回退到上一级。</p>\n</blockquote>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  openSlideViewLeftHolder?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>该值默认为 false。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        defaultSlideViewApplets: [\n          {\n            id: &#39;appletA&#39;,\n            activate: &#39;instant&#39;,\n          },\n          {\n            id: &#39;appletB&#39;,\n            activate: &#39;lazy&#39;,\n          },\n        ],\n        openSlideViewLeftHolder: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>开启该选项后需要注意程序卡左侧边缘将产生 20px 的无反馈区域，开发时应注意预留该安全操作距离。</p>\n</div>\n    '},6728:n=>{n.exports='\n    \n<div class="card">\n  <h1>Portal</h1>\n\n<p><small>AppletConfig &gt; portal</small></p>\n<p>开启该属性的程序卡在浏览器支持 portal 特性时，在转场动画结束后会执行 portal 的激活操作，激活后程序卡页面将在新的上下文中运行。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  portal?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>程序卡的 source 配置应为链接模式，且与主应用同域。</p>\n<p>设置为 portal 的程序卡， 其[free]选项一般也应设置为 true。</p>\n<p>当浏览器不支持 portal 能力时会自动降级为一般容器模式。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        portal: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>该选项适用于功能独立且与主应用没有任何的联系的（如 apply、inject 等）程序卡，否则，将会导致这些依赖上下文的配置失效。</p>\n</div>\n    '},4545:n=>{n.exports='\n    \n<div class="card">\n  <h1>PreIndex</h1>\n\n<p><small>FrameworksAppletConfig &gt; preIndex</small></p>\n<p>通过链接访问某个程序卡时，可在之前插入一个前置的程序卡。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface FrameworksAppletConfig {\n  preIndex?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>当通过访问页面 url 锚定到某个程序卡时，可以通过此配置项设置一个前置程序卡，此时访问该 url 链接时依然会优先访问锚定的程序卡，但当点击浏览器返回时并不会立刻退出，而是从锚定程序卡回退到通过该配置项插入的前置程序卡。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        preIndex: &#39;home&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>当访问链接所锚定的程序卡和 [preIndex] 或 [index] 相等时则不会在之前再次插入前置程序卡。</p>\n</div>\n    '},5078:n=>{n.exports='\n    \n<div class="card">\n  <h1>Prerender</h1>\n\n<p><small>AppletConfig &gt; prerender</small></p>\n<p>程序卡的预加载&amp;预渲染。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  prerender?: Array&lt;string&gt;\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>当前程序卡中如果存在链接到其它程序卡，且希望能预先载入这些程序卡时，则可进行设置该属性。页面会在空闲时对依赖的程序卡进行后台的预加载，包括文档中的 css 以及 js 等静态资源的预加载。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      prerender: [${AppletName}, ${AppletName}]\n    }\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>当预载执行时，用户访问该程序卡时将节省内链静态资源的加载，但是对于脚本的动态数据请求并不会有所提前，如果想提前数据的加载，则需配合前一个程序卡使用[inject]能力或“postMessage”能力进行前置。</p>\n<blockquote>\n<p>prerender 目前浏览器尚无法完成预渲染工作，其当前阶段的能力表述更接近“prefetch”，尽管如此，但我们希望在未来能预留预渲染的能力，因此它依旧保留该选项为“prerender”的称呼。</p>\n</blockquote>\n</div>\n    '},9227:n=>{n.exports='\n    \n<div class="card">\n  <h1>PullToRefresh</h1>\n\n<p><small>AppletConfig &gt; pullToRefresh</small></p>\n<p>开启后，在主滚动容器持续下拉手势时将会触发页面无缝刷新。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  pullToRefresh?: boolean\n  pullToRefreshTargetScrollId?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>开启该选项的前提是“FrameworksApplet”也开启了该选项，否则将无法生效。</p>\n<p>下拉刷新将关联一个滚动容器，可通过“pullToRefreshTargetScrollId”指定容器“id”。</p>\n<p>若未指定容器，则会默认关联主滚动容器，主滚动条请参考配置项“mainScrollId”，默认主滚动关联为程序卡的 &lt;define-applet&gt; 容器。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        pullToRefresh: true,\n        pullToRefreshTargetScrollId: &#39;root&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>注意指定的滚动容器“id”不可存在于 ShadowDom 中。</p>\n</div>\n    '},1208:n=>{n.exports='\n    \n<div class="card">\n  <h1>Render</h1>\n\n<p><small>AppletConfig &gt; render</small></p>\n<p>除了通过配置项[source]定义程序卡视图，还可以通过 render 方法来直接渲染元素到程序卡内。</p>\n<p>render 进行定义的程序卡将使用 shadowDom 模式。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  render?: (target: HTMLElement) =&gt; void\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>render 函数将程序卡的根节点传入，开发者可将渲染视图直接插入到节点内。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        render: (target) =&gt; {\n          target.innerHTML = `\n              &lt;p&gt;Hello World&lt;/p&gt;\n            `\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>使用 render 函数的最佳实践方案是把业务逻辑与模块配置进行分离，可使用动态 import 来引入业务逻辑的部分。</p>\n</div>\n    '},6108:n=>{n.exports='\n    \n<div class="card">\n  <h1>Resource</h1>\n\n<p><small>AppletManifest &gt; resource</small></p>\n<p>程序卡运行时所依赖的静态资源。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletResources {\n  script?: Array&lt;string&gt;\n  image?: Array&lt;string&gt;\n  worker?: Array&lt;string&gt;\n  video?: Array&lt;string&gt;\n  audio?: Array&lt;string&gt;\n  font?: Array&lt;string&gt;\n  style?: Array&lt;string&gt;\n  html?: Array&lt;string&gt;\n}\ninterface AppletManifest {\n  resource?: AppletResources\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>从当前程序卡切换到下一程序卡时，若当前程序卡配置了预渲染依赖(prerender=[${nextApplet}])时，在下一个程序卡被加载前进行其静态资源的预载入，如 html 中的 script、css 标签等，对于这些内链的静态资源是无需进行声明配置的，但是对于页面运行期间通过脚本动态加载的内容，如 css 中的 font 字体，动态产生的的媒体素材等，并不能完成预先的载入，此时则可通过 resource 配置项将可能发生加载的资源进行预载。</p>\n<p>程序卡层级关系还将反应在转场动画的效果上，从小到大为正向动画，反之从大到小时为逆向动画。</p>\n<p>当历史回退到层级为 0 的程序卡时，会触发 singleLock 事件，具体可查看 [singleLock] 配置中的相关描述。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      resource: [\n        image: [\n          &#39;https://yourCDN.com/001.jpg&#39;,\n          &#39;https://yourCDN.com/002.jpg&#39;,\n          &#39;https://yourCDN.com/003.jpg&#39;\n        ]\n      ],\n      config: {\n        title: &#39;Home Page&#39;\n      }\n    }\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>预载工作并不是立刻执行的，而是在浏览器空闲时按顺序依次载入。</p>\n<blockquote>\n<p>非存在于 AppletResources 类型中的未知类型可尝试使用 script 类型进行预载。</p>\n</blockquote>\n</div>\n    '},1919:n=>{n.exports='\n    \n<div class="card">\n  <h1>SafeArea</h1>\n\n<p><small>AppletConfig &gt; safeArea</small></p>\n<p>定义全局的 CSS 应用安全边距变量。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type ApplicationSafeAreaValue = string | Array&lt;string&gt;\ninterface AppletBaseConfig {\n  safeArea?: ApplicationSafeAreaValue | (() =&gt; ApplicationSafeAreaValue)\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>值为数字时，分别按顺序表示 顶部、右侧、底部、左侧 的安全边距。</p>\n<p>设置该值后将会在程序卡的全局样式中注入 CSS 全局变量：--application-safe-area-top、--application-safe-area-right、--application-safe-area-bottom、--application-safe-area-left 四个对应的安全边距值。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        safeArea: [&#39;44px&#39;, &#39;0px&#39;, &#39;0px&#39;, &#39;0px&#39;],\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>如果需要动态的修改这个值则可以通过发送“safeAreaChange”事件来进行更新。</p>\n<pre><div class="docs-code"><code-highlight type="ts">application.trigger(&#39;safeAreaChange&#39;, [&#39;88px&#39;, &#39;0px&#39;, &#39;0px&#39;, &#39;0px&#39;])\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>当 frameworks 程序卡带有头部导航时，为了能让程序卡正常预留导航栏高度，使用该配置能动态调整该高度。</p>\n</div>\n    '},470:n=>{n.exports='\n    \n<div class="card">\n  <h1>Sandbox</h1>\n\n<p><small>AppletConfig &gt; sandbox</small></p>\n<p>程序卡容器的沙盒限制。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">type SandboxOptions = Array&lt;\n  | &#39;allow-same-origin&#39;\n  | &#39;allow-scripts&#39;\n  | &#39;allow-forms&#39;\n  | &#39;allow-modals&#39;\n  | &#39;allow-orientation-lock&#39;\n  | &#39;allow-popups&#39;\n  | &#39;allow-pointer-lock&#39;\n  | &#39;allow-popups-to-escape-sandbox&#39;\n  | &#39;allow-presentation&#39;\n  | &#39;allow-top-navigation&#39;\n  | &#39;allow-top-navigation-by-user-activation&#39;\n  | &#39;allow-downloads-without-user-activation&#39;\n  | &#39;allow-storage-access-by-user-activation&#39;\n  | &#39;allow-top-navigation-by-user-activation&#39;\n  | string\n&gt;\ninterface AppletBaseConfig {\n  sandbox?: SandboxOptions\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>该选项仅适用于拥有[source]选项设定的程序卡。</p>\n<p>关于 Sandbox 的更多信息，请参照 W3C 定义。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        sandbox: &#39;allow-modals&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>若你的程序卡页面为第三方链接，出于对安全性的考虑可通过此选项对其不必要的权限进行限制。</p>\n</div>\n    '},2710:n=>{n.exports='\n    \n<div class="card">\n  <h1>Animate Effect</h1>\n\n<p><small>AppletConfig &gt; animation</small></p>\n<p>设置程序卡窗口转场时的动画效果。</p>\n<hr>\n<p><small>AppletConfig &gt; animationUnderUntouchable</small></p>\n<p>设置在不支持触摸屏设备上的（pc 等设备）程序卡窗口转场时的动画效果。</p>\n<hr>\n<h3>Types</h3>\n\n<p>Lath 已经内置了常用的动画效果，同时也允许开发者开发自定义的动画效果。</p>\n<pre><div class="docs-code"><code-highlight type="ts">type AnimationFunction = (e: SegueAnimateState) =&gt; undefined | Promise&lt;boolean&gt;\ntype AnimationPrestType =\n  | &#39;inherit&#39;\n  | &#39;fade&#39;\n  | &#39;zoom&#39;\n  | &#39;flip&#39;\n  | &#39;flip-left&#39;\n  | &#39;flip-down&#39;\n  | &#39;flip-right&#39;\n  | &#39;flip-up&#39;\n  | &#39;slide&#39;\n  | &#39;slide-left&#39;\n  | &#39;slide-right&#39;\n  | &#39;slide-up&#39;\n  | &#39;slide-down&#39;\n\ntype SwipeTransitionType = &#39;zoom&#39; | &#39;slide&#39;\n\ntype AnimationConfig =\n  | AnimationPrestType\n  | boolean\n  | Array&lt;AnimationPrestType&gt;\n  | [AnimationFunction, AnimationFunction]\n\ninterface AppletBaseConfig {\n  animation?: AnimationPrestType\n  animationUnderUntouchable?: AnimationConfig\n}\n</code-highlight></div></pre>\n<p>SegueAnimateState 为自定义动画中提供的可用对象。</p>\n<pre><div class="docs-code"><code-highlight type="ts">declare interface SegueActionOrigin {\n  x: number\n  y: number\n  target: HTMLElement\n}\ndeclare interface SegueAnimateState {\n  x: number\n  y: number\n  in: Animate\n  out: Animate\n  view: Array&lt;HTMLElement&gt;\n  width: number\n  height: number\n  viewports: Array&lt;HTMLElement&gt;\n  applets: Array&lt;Applet&gt;\n  reverse: boolean\n  direction: number\n  fallbackState: number\n  origin: string | Array&lt;number&gt;\n  attach: string | Array&lt;number&gt;\n  touches: SegueActionOrigin | undefined\n  swipeTransitionType: SwipeTransitionType\n  historyDirection: number\n  callback: (stillness: boolean) =&gt; void\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>Lath 提供了常见的动画效果选择，只需指定你预置的效果名即可实现炫酷的窗口动画。</p>\n<p>程序卡默认的转场过渡动画为 <strong>slide-left</strong> 效果，在开启 <a href="?id=swipeModel#docs">swipeModel</a>时，该效果在 IOS 设备中将得到另一个线程上的性能加速，对比其它转场效果，其在帧率表现上是<b>性能最佳的选项</b>。</p>\n<p>设置值为 <strong>inherit</strong> 以及未配置时，则该选项将继承 FrameworksApplet 中的值。</p>\n<p>配置项类型若为数组，则数组中的第一个函数为正向动画，第二个函数为逆向动画。如果值为函数，则可通过 <strong>SegueAnimateState</strong> 中的状态信息手动进行动画控制，比如 direction、historyDirection 等。</p>\n<hr>\n<h3>Example</h3>\n\n<p>定义内置的动画效果很简单，就像下面这样：</p>\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        animation: &#39;slide&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>定义一个自定义动画将会复杂一点，下面以 fade 动画为例：</p>\n<pre><div class="docs-code"><code-highlight type="ts">import { SegueAnimateState, Animate } from &#39;lath/app/types&#39;\nconst getAnimate = (type: number) =&gt; {\n  return (type: number) =&gt; {\n    return async (state: SegueAnimateState) =&gt; {\n      let inO: number, outO: number, inV: Animate, outV: Animate\n      switch (type) {\n        case 0:\n          inO = 1\n          outO = 0\n          inV = state.in\n          outV = state.out\n          break\n        case 1:\n        default:\n          inO = 0\n          outO = 1\n          inV = outV = state.in\n      }\n      await inV.duration(0).to(0, 0, 0).opacity(inO).end()\n      await outV.duration(300).opacity(outO).end()\n      return Promise.resolve(false)\n    }\n  }\n}\ncreateApplication({\n  applets: {\n    home: {\n      config: {\n        animation: [getAnimate(0), getAnimate(1)],\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>当然你也可以直接使用函数来处理动画效果：</p>\n<pre><div class="docs-code"><code-highlight type="ts">import { SegueAnimateState, Animate } from &#39;lath/app/types&#39;\ncreateApplication({\n  applets: {\n    home: {\n      config: {\n        animation: async (state: SegueAnimateState) =&gt; {\n          if (!state.reverse) {\n            await inV.duration(0).to(0, 0, 0).opacity(1).end()\n            await outV.duration(300).opacity(0).end()\n          } else {\n            await inV.duration(0).to(0, 0, 0).opacity(0).end()\n            await outV.duration(300).opacity(1).end()\n          }\n          return Promise.resolve(false)\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>一些场景下转场动画可能会失效，比如 Applet 设置为了 <a href="?id=modality#docs">modality</a> 模式时，自定义动画将被强制转换。</p>\n<blockquote>\n<p>每个预制的动画都包涵一个前进动画以及倒退动画，采用哪种效果将会受到你浏览历史的方向甚至程序卡之间的[level]层级所决定。</p>\n</blockquote>\n\n</div>\n<div class="card">\n  <h1>Demo</h1>\n\n<ul>\n<li>左侧滑动(默认) <a href="#empty" preset-effect="slide-left" clone-as="empty-left">slide-left</a></li>\n<li>右侧滑动 <a href="#empty" preset-effect="slide-right" clone-as="empty-right">slide-right</a></li>\n<li>上侧滑动 <a href="#empty" preset-effect="slide-up" clone-as="empty-up">slide-up</a></li>\n<li>下侧滑动 <a href="#empty" preset-effect="slide-down" clone-as="empty-down">slide-down</a></li>\n<li>放大镜 <a href="#empty" preset-effect="zoom" clone-as="empty-zoom">zoom</a></li>\n<li>翻转 <a href="#empty" preset-effect="flip" clone-as="empty-flip">flip</a></li>\n<li>左侧翻转 <a href="#empty" preset-effect="flip-left" clone-as="empty-flip-left">flip-left</a></li>\n<li>右侧翻转 <a href="#empty" preset-effect="flip-right" clone-as="empty-flip-right">flip-right</a></li>\n<li>上侧翻转 <a href="#empty" preset-effect="flip-up" clone-as="empty-flip-up">flip-up</a></li>\n<li>下侧反转 <a href="#empty" preset-effect="flip-down" clone-as="empty-flip-down">flip-down</a></li>\n<li>渐变 <a href="#empty" preset-effect="fade" clone-as="empty-fade">fade</a></li>\n</ul>\n</div>\n    '},9107:n=>{n.exports='\n    \n<div class="card">\n  <h1>SingleFlow</h1>\n\n<p><small>FrameworksAppletConfig &gt; singleFlow</small></p>\n<p>开启历史层级流向控制。（frameworks 程序卡专属配置）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface FrameworksAppletConfig {\n  singleFlow?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>只允许程序卡的历史回退方向往 level 较小的程序卡回退，若在返回时，返回的程序卡 level 层级若大于或等于当前程序卡层级，则直接跳过该程序卡，继续返回到历史记录中更早的程序卡，直至条件符合。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        singleFlow: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>例如从生成订单功能的程序卡到支付订单的程序卡付款成功后进入我的订单模块程序卡，其在完成后进行回退时可通过开启配置项并结合程序卡 level 规则，使其直接回到订单生程序卡，而无需经过订单完成过程中的各个程序卡。</p>\n</div>\n    '},5605:n=>{n.exports='\n    \n<div class="card">\n  <h1>SingleLock</h1>\n\n<p><small>FrameworksAppletConfig &gt; singleLock</small></p>\n<p>当程序卡回退到程序出口（level === 0 的程序卡）时，进行返回操作时组织历史继续回退。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface FrameworksAppletConfig {\n  singleLock?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>当回退被锁定时，继续回退会开始记录回退次数，并可通过 frameworks Applet 中的 [holdBack] 配置来决定程序卡是否允许退出。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        singleLock: true,\n        holdBack: (event) =&gt; {\n          // 判断是否退出\n          return true\n        },\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>如上配置，从其它页面跳转进入到应用时，当点击浏览器返回按钮时并不会退出应用页面，而是会通过 Frameworks Applet 中的 [holdBack] 配置进行判断是否应该被退出，并同时返回用户点击返回按钮的次数。</p>\n</div>\n    '},8704:n=>{n.exports='\n    \n<div class="card">\n  <h1>Source</h1>\n\n<p><small>AppletConfig &gt; source</small></p>\n<p>定义程序卡的 HTML 源代码，该源代码将在 Lath 创建的容器内运行。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  source?: EitherOr&lt;\n    {\n      src?: string\n      html?: string | (() =&gt; Promise&lt;string&gt; | string)\n    },\n    &#39;src&#39;,\n    &#39;html&#39;\n  &gt;\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>可设置为源码模式与链接模式两种模式。</p>\n<hr>\n<h3>Example</h3>\n\n<p><strong>源码模式</strong></p>\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        title: &#39;Home Page&#39;,\n        source: {\n          html: `\n            &lt;html lang=&quot;en&quot;&gt;\n            &lt;head&gt;&lt;/head&gt;\n            &lt;body&gt;\n              Hello World!\n            &lt;/body&gt;\n            &lt;/html&gt;\n            `\n        },\n        ...\n      }\n    },\n    ...\n  }\n})\n</code-highlight></div></pre>\n<p><strong>链接模式</strong></p>\n<pre><div class="docs-code"><code-highlight type="js">export default {\n  config: {\n    title: &#39;Home Page&#39;,\n    source: {\n      src: &#39;http://yoursite.com&#39;,\n    },\n  },\n}\n</code-highlight></div></pre>\n<p>两种模式选其一，若共存时将以 src 链接模式优先。</p>\n<hr>\n<h3>Notes</h3>\n\n<p>使用链接模式时需符合同源策略，否者某些能力将无法开启，比如 Capture、Apply、Inject 等。若需要使用这些特性，则需要将目标页面也同样接入 lath，并开启“隧穿”模式，可参考“PresetConfig &gt; tunneling”。</p>\n</div>\n    '},194:n=>{n.exports='\n    \n<div class="card">\n  <h1>为什么用？</h1>\n\n<p>如果你想用 WEB 技术创建令人愉悦的 APP 体验，<strong>通常你会面临以下问题</strong>：</p>\n<ul>\n<li>将不同技术类型的页面组装到一起，并确保互不干扰</li>\n<li>页面之间进行路由需要具备流畅的转场效果和手势操作，尤其是在性能方面会是一个挑战</li>\n<li>需要自行完成页面的预载加速以及生命周期管理等复杂的系统设计</li>\n<li>创建良好的配置化与自动化系统</li>\n</ul>\n<p>在实际操作中你可能会面临更多的困难和挑战。现在，这一切都将变得更加简单，你只需使用 Lath。</p>\n\n</div>\n<div class="card">\n  <h1>概念</h1>\n\n<p>快速入门前，让我们先了解一下基本概念和名词。</p>\n<ul>\n<li><strong>Lath</strong>: Lath (中文名：板条) 是一个体验增强容器，首次依赖仅有 <b>5kb</b> 左右。其原子化的核心能力能够自动按需载入。</li>\n<li><strong>Application</strong>: 一个 Lath 应用是由若干个程序卡（Applet）组成的。</li>\n<li><strong>Applet</strong>: 一个程序卡是由一个页面或一个 View、以及其有关配置文件所组成的。</li>\n<li><strong>FrameworksApplet</strong>: 每个 Lath 应用必有一个框架类型的程序卡，其主要承载公共能力，比如导航栏等等。</li>\n</ul>\n<blockquote>\n<p>Lath 应用是一个单页面应用（SPA），由若干个 Applet 组成。每个 Applet 都可以通过&lt;define-applet&gt;定义一个内部区块视图，或者通过 config.source 定义一个外部页面视图。</p>\n</blockquote>\n\n</div>\n<div class="card">\n  <h1>使用</h1>\n\n<p>使用 <strong>npm / yarn</strong> 安装</p>\n<pre><div class="docs-code"><code-highlight type="bash">$ npm install lath --save\n// or\n$ yarn add lath\n</code-highlight></div></pre>\n<hr>\n<p>假使我们现在要制作一个单页应用 (SPA)，并且我们已经制作好应用对应的每一个路由页面(Applet)，那么我们只需要通过下面的方式将其组装：\n使用 <strong>&lt;define-application&gt;</strong> 容器作为根节点来包裹页整个面内容，使页面被声明为一个 Lath 应用，然后在其内部使用 <strong>&lt;define-applet&gt;</strong> 容器包裹具体的路由视图（我们可以理解为传统 SPA 应用中的一个页面）使包裹视图被声明为一个 Applet 实体的视图。</p>\n<pre><div class="docs-code"><code-highlight type="html">&lt;body&gt;\n  &lt;define-application default-applet=&quot;appletA&quot;&gt;\n    &lt;define-applet applet-id=&quot;appletA&quot;&gt;\n      &lt;div&gt;This is the content of &#39;appletA&#39;&lt;/div&gt;\n    &lt;/define-applet&gt;\n    &lt;define-applet applet-id=&quot;appletB&quot;&gt;\n      &lt;div&gt;This is the content of &#39;appletB&#39;&lt;/div&gt;\n    &lt;/define-applet&gt;\n  &lt;/define-application&gt;\n&lt;/body&gt;\n</code-highlight></div></pre>\n<ul>\n<li>&lt;define-application&gt; 上的属性 <b>“default-applet”</b> 可指定一个 Applet 名，做为初始化应用时的默认视图，即希望第一时间让用户可见的视图。</li>\n<li>&lt;define-applet&gt; 上的属性 <b>“applet-id”</b> 为声明的 Applet 名。</li>\n</ul>\n<blockquote>\n<p>“default-applet” 为 &lt;define-application&gt; 包裹中已经通过 &lt;define-applet&gt; 所声明的 Applet，当页面在浏览器中打开时仅该指定的 Applet 视图是可见的，其余视图则不可见。</p>\n</blockquote>\n<p>使用标签包裹是创建 Lath 应用的第一步，下面我们还要为每个已声明的 Applet 进行特性配置，比如为每个 Applet 设定一个标题。</p>\n<pre><div class="docs-code"><code-highlight type="ts">import { createApplication } from &#39;lath&#39;\ncreateApplication({\n  applets: {\n    frameworks: {\n      config: {\n        title: &#39;Lath Demo&#39;,\n      },\n    },\n    appletA: {\n      config: {\n        title: &#39;Page A&#39;,\n      },\n    },\n    appletB: {\n      config: {\n        title: &#39;Page B&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<p>我们使用 &lt;define-application&gt; 容器是为了声明应用，但要真正启动应用还需要执行 <strong>createApplication</strong> 方法，并传入 Applet 相关配置。</p>\n<p>不出意外我们将得到一个“施了魔法”的页面，此时我们可以通过 A 链接或 <a to-applet="docs?id=apiApplicationTo" clone-as="popDoc">Application.to</a> 等方法路由到已定义的程序卡视图上。</p>\n<p>一般情况下我们不会将应用中所有可能被加载的路由页面都一次性集成在一个页面中，而是希望能按需载入，那我们只需通过配置信息来表达即可：</p>\n<pre><div class="docs-code"><code-highlight type="ts">import { createApplication } from &#39;lath&#39;\ncreateApplication({\n  applets: {\n    frameworks: {\n      config: {\n        title: &#39;Lath Demo&#39;,\n      },\n    },\n    home: {\n      config: {\n        title: &#39;home&#39;,\n        source: {\n          src: &#39;https://www.yoursite.com/home.html&#39;,\n        },\n      },\n    },\n  },\n}).then((application) =&gt; {\n  // 返回 application 对象\n  console.log(application)\n})\n</code-highlight></div></pre>\n<p>Applet 的视图不光可以通过 &lt;define-applet&gt; 进行声明，也可以通过配置项 <a to-applet="docs?id=source" clone-as="popDoc">source</a> 进行声明。\n当使用 source 定义 Applet 视图时则无需再使用 &lt;define-applet&gt; 进行声明。\n一般我们会将 frameworks 程序卡和首屏程序卡通过 &lt;define-applet&gt; 的方式进行声明，其余程序卡则通过配置 source 的方式进行声明，这样可以保证最大程度的首屏加载速度。</p>\n</div>\n    '},1009:n=>{n.exports='\n    \n<div class="card">\n  <h1>TapStatusBarToScrollToTop</h1>\n\n<p><small>AppletConfig &gt; tapStatusBarToScrollToTop</small></p>\n<p>开启后，在点击窗口顶部状态栏时，主滚动容器将滚动到顶部。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  tapStatusBarToScrollToTop?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>该选项将将反映在主滚动上，主滚动条请参考配置项“mainScrollId”，默认主滚动关联为程序卡的 body 容器。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        tapStatusBarToScrollToTop: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>该选项的启动须依赖配置项“mainScrollId”。</p>\n</div>\n    '},1902:n=>{n.exports='\n    \n<div class="card">\n  <h1>Timeout</h1>\n\n<p><small>AppletConfig &gt; timeout</small></p>\n<p>程序卡生命周期的有效时长，单位为毫秒。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  timeout?: number\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>程序卡符合缓存条件或设置为允许背景运行(background=true)时，程序卡在二次进入前会检查过期情况，当检查到程序卡已过期时将会进行更新操作。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        timeout: 36000,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>若该值设置为 0 时，则背景运行(background=true)将不会生效。</p>\n</div>\n    '},1937:n=>{n.exports='\n    \n<div class="card">\n  <h1>Title</h1>\n\n<p><small>AppletConfig &gt; title</small></p>\n<p>程序卡标题，主要用于浏览器窗口标题的显示。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  title?: string\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>当窗口切换时，该配置项相当于页面中的 &quot;Title&quot; 标签的作用。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        title: &#39;Home Page&#39;,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<blockquote>\n<p>当 system 程序卡、 frameworks 程序卡 以及首页程序卡同时设置 title 时，它们的显示权重是： 首页程序卡 &gt; frameworks 程序卡 &gt; system 程序卡。而实际上 system 类型程序卡的此选项是不必要的，因为它从不会生效。</p>\n</blockquote>\n</div>\n    '},9202:n=>{n.exports='\n    \n<div class="card">\n  <h1>Transient</h1>\n\n<p><small>AppletConfig &gt; transient</small></p>\n<p>标记该程序卡为临时模块。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  transient?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>在程序卡切换到后台时，会被立即销毁，并同时删除程序卡的所有临时配置数据。</p>\n<p>通过新窗口打开（A 链接 或 API - pushWindow）的 url 类型程序卡（即无自定义配置的临时模块），会被自动进行该标记。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    demoPage: {\n      config: {\n        transient: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>一般当你的程序卡不存在重复利用时可使用该参数，比如无法枚举的通过动态生成的程序卡。</p>\n<blockquote>\n<p>该配置项的意义是什么？当 A 链接所访问的生成模块时，由于链接无法枚举，因此会累积很多无用的程序卡配置，因此开启该选项能够消除这些无意义的内存消耗。</p>\n</blockquote>\n\n</div>\n<div class="card">\n  <h1>DisableTransient</h1>\n\n<p><small>AppletConfig &gt; disableTransient</small></p>\n<p>DisableTransient 和 Transient 相呼应，可通过此参数来关闭默认的 Transient 行为。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  disableTransient?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>若在某种特殊情境下，模块无须定义任何配置（或开发者懒于设置）而实际上模块是可枚举的（自动生成的配置也是有意义的，其存在重用的可能而并非临时程序卡），因此配置该选项时可关闭自动清除生成的程序卡配置的机制。</p>\n</div>\n    '},9230:n=>{n.exports='\n    \n<div class="card">\n  <h1>Tunneling</h1>\n\n<p><small>PresetConfig &gt; tunneling</small></p>\n<p>设定应用为“隧穿模式”。（应用启动前的预配置项）</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface PresetConfig {\n  tunneling?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<blockquote>\n<p>若在当前域下访问跨域的程序卡，此时会因同源策略导致跨域的程序卡无法实现，全局样式变量更新以及[Apply]中的能力（比如新开窗口）。</p>\n</blockquote>\n<p>通过将跨域程序卡页面接入 Lath，并开启 [tunneling]来解决跨域程序卡页面的一些受限能力。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  tunneling: true,\n  applets: {\n    ...\n  }\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>当页面接入 Lath 且开启 [tunneling] 时，页面本身即为一个单独应用，但当该页面嵌入到另一个 Lath 应用作为程序卡时，其通过 A 链接（即 pushWindow）打开的页面将不会在本应用内打开，而是被代理到父级应用中打开，若父级应用也是被嵌入的 Lath 应用，且也开启了 [tunneling] 则会继续向上“隧穿”。</p>\n</div>\n    '},615:n=>{n.exports='\n    \n<div class="card">\n  <h1>制作滑动卡片效果</h1>\n\n<p style="font-size: 21px;font-weight: bold;">滑动切卡效果就是将多个 Applet 并排一列，通过左右的滑动手势实现 Applet 之间的切换。</p>\n          <div style="display: flex; width: 100%; box-sizing: border-box; height: 300px; padding: 10px; border-radius: 18px; background: linear-gradient(300deg, rgb(0, 164, 255, 0.27), #ff8351);transform: translate3d(10px, 10px, 10px) perspective(1000px) rotateX(10deg) rotateY(50deg);">\n            <div style="min-width: 90%; height: 260px; border-radius: 18px; margin: 10px 0 0 -50%; border: 1px solid rgba(0,0,0,.1); background: rgb(0, 164, 255, 0.27); color: #fff2ee70; backdrop-filter: saturate(180%) blur(5px); line-height: 260px; font-size: 80px; text-indent: 20px;">PageA</div>\n            <div style="min-width: 90%; height: 260px; border-radius: 18px; margin: 10px 0 0 10px; border: 1px solid rgba(0,0,0,.1); background: rgb(0, 164, 255, 0.27); color: #3a1500; backdrop-filter: saturate(180%) blur(5px); line-height: 260px; font-size: 70px; text-indent: 20px;">PageB</div>\n          </div>\n\n<p>这会很容易让我们联想到 <strong>Tab</strong> 功能，但他们存在一些微的小区别，比如 Tab 一般是不具有滑动手势的。</p>\n<p>我们在实现这个效果前需要确定滑动卡片的效果是由哪个视图承接的，即实现该效果的 Applet 是谁，同时在这个视图中所嵌套的并排可滑动的 Applet 是谁？确定好这些之后我们就可以开始创建效果了，用到配置项 <a to-applet="docs?id=defaultSlideViewApplets">defaultSlideViewApplets</a></p>\n<p>假使我们有三个 Applet 分别命名为 A、 B 、C，我们希望有一个视图可以同时承载 ABC 三个 Applet，并使它们能够呈现 Slider 效果。</p>\n<p>我们新建一个 Applet D，它并不具备任何自身的视图，而仅是作为空容器将 ABC 三个 Applet 引入进来，那么此时我们导航进入到 D 时就可看到一个 Slider 效果的视图了，如果我们希望访问到 B，则只需先访问 D 再访问 B，若已经存在 D 则可直接访问 B 即可。</p>\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    frameworks: {\n      config: {\n        index: &#39;D&#39;,\n      },\n    },\n    A: {\n      config: {\n        source: {\n          src: &#39;./a.html&#39;,\n        },\n      },\n    },\n    B: {\n      config: {\n        source: {\n          src: &#39;./b.html&#39;,\n        },\n      },\n    },\n    C: {\n      config: {\n        source: {\n          src: &#39;./c.html&#39;,\n        },\n      },\n    },\n    D: {\n      config: {\n        defaultSlideViewApplets: [\n          {\n            id: &#39;A&#39;,\n            activate: &#39;instant&#39;,\n          },\n          {\n            id: &#39;B&#39;,\n            activate: &#39;lazy&#39;,\n          },\n          {\n            id: &#39;C&#39;,\n            activate: &#39;lazy&#39;,\n          },\n        ],\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n</div>\n    '},7851:n=>{n.exports='\n    \n<div class="card">\n  <h1>UseMirroring</h1>\n\n<p><small>AppletConfig &gt; useMirroring</small></p>\n<p>持久化保存上次访问的镜像文件，以便下次访问时快速呈现。</p>\n<hr>\n<h3>Types</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">interface AppletBaseConfig {\n  useMirroring?: boolean\n}\n</code-highlight></div></pre>\n<hr>\n<h3>Details</h3>\n\n<p>当程序卡页面销毁时，将会对其内部 HTML 进行本地化持久存储，当下次访问时会立刻呈现上次访问结果，直到新内容加载完成后消失。</p>\n<hr>\n<h3>Example</h3>\n\n<pre><div class="docs-code"><code-highlight type="ts">createApplication({\n  applets: {\n    home: {\n      config: {\n        useMirroring: true,\n      },\n    },\n  },\n})\n</code-highlight></div></pre>\n<hr>\n<h3>Notes</h3>\n\n<p>当本地存储溢出时会清空所有 localStorge 本地数据，一般在一些变动频次较低的场景使用，使用前请充分考虑展示逻辑的合理性。</p>\n<blockquote>\n<p>镜像的还原不能存储和还原页面中的 Web Components、 ShadowDom 以及 iframe、canvas、object 等嵌入媒体，当使用该选项时应当考虑这些因素。</p>\n</blockquote>\n</div>\n    '},7985:(n,e,t)=>{"use strict";t.r(e),t.d(e,{FAQ:()=>p,allowHost:()=>i,apiAppletColor:()=>l,apiAppletEvents:()=>o,apiAppletRefresh:()=>a,apiAppletSameOrigin:()=>s,apiAppletSlideView:()=>r,apiAppletView:()=>h,apiAppletViewType:()=>c,apiApplicationActivityApplet:()=>d,apiApplicationEvents:()=>m,apiApplicationExists:()=>x,apiApplicationGet:()=>g,apiApplicationPreActivityApplet:()=>S,apiApplicationPushWindow:()=>T,apiApplicationTo:()=>v,apiApplicationUpdateGlobalCSSVariables:()=>f,apiApplicationUpdateSafeArea:()=>A,appletManifestProcess:()=>u,apply:()=>y,background:()=>b,capture:()=>w,color:()=>k,components:()=>q,customEffect:()=>N,defaultSlideViewApplets:()=>B,events:()=>C,free:()=>E,globalCSSVariables:()=>D,holdBack:()=>V,index:()=>P,inject:()=>O,level:()=>L,limit:()=>M,mainScrollId:()=>en,mediaGuard:()=>F,modality:()=>R,noShadowDom:()=>H,notFound:()=>$,openSlideViewLeftHolder:()=>nn,portal:()=>W,preIndex:()=>I,prerender:()=>G,pullToRefresh:()=>j,render:()=>z,resource:()=>U,safeArea:()=>_,sandbox:()=>Q,segueEffect:()=>J,singleFlow:()=>X,singleLock:()=>Z,source:()=>Y,start:()=>K,tapStatusBarToScrollToTop:()=>tn,timeout:()=>pn,title:()=>ln,transient:()=>on,tunneling:()=>an,tutorialSlidingCards:()=>sn,useMirroring:()=>rn});var p=t(2078),i=t(4950),l=t(614),o=t(910),a=t(6283),s=t(4323),r=t(6358),h=t(1715),c=t(2681),d=t(5139),g=t(2517),m=t(2950),v=t(5481),f=t(9265),A=t(7694),u=t(4785),y=t(9678),b=t(6425),w=t(9420),x=t(1671),T=t(3809),S=t(9384),k=t(2550),C=t(1714),E=t(5066),D=t(6229),V=t(9076),P=t(8314),B=t(6534),L=t(9041),M=t(571),O=t(5091),q=t(3527),N=t(758),H=t(6566),F=t(3367),R=t(8887),W=t(6728),I=t(4545),G=t(5078),j=t(9227),z=t(1208),U=t(6108),_=t(1919),$=t(3584),J=t(2710),X=t(9107),Q=t(470),Y=t(8704),K=t(194),Z=t(5605),nn=t(4631),en=t(9790),tn=t(1009),pn=t(1902),ln=t(1937),on=t(9202),an=t(9230),sn=t(615),rn=t(7851)}}]);