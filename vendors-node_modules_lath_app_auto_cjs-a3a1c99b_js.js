(self["webpackChunklath_docs"] = self["webpackChunklath_docs"] || []).push([["vendors-node_modules_lath_app_auto_cjs-a3a1c99b_js"],{

/***/ "./node_modules/compute-scroll-into-view/dist/index.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/compute-scroll-into-view/dist/index.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function t(t){return"object"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return(!e||"hidden"!==t)&&"visible"!==t&&"clip"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(e,i){var o=window,l=i.scrollMode,d=i.block,u=i.inline,h=i.boundary,a=i.skipOverflowHiddenElements,c="function"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError("Invalid target");for(var f=document.scrollingElement||document.documentElement,s=[],p=e;t(p)&&c(p);){if((p=p.parentElement)===f){s.push(p);break}null!=p&&p===document.body&&n(p)&&!n(document.documentElement)||null!=p&&n(p,a)&&s.push(p)}for(var m=o.visualViewport?o.visualViewport.width:innerWidth,g=o.visualViewport?o.visualViewport.height:innerHeight,w=window.scrollX||pageXOffset,v=window.scrollY||pageYOffset,W=e.getBoundingClientRect(),b=W.height,H=W.width,y=W.top,E=W.right,M=W.bottom,V=W.left,x="start"===d||"nearest"===d?y:"end"===d?M:y+b/2,I="center"===u?V+H/2:"end"===u?E:V,C=[],T=0;T<s.length;T++){var k=s[T],B=k.getBoundingClientRect(),D=B.height,O=B.width,R=B.top,X=B.right,Y=B.bottom,L=B.left;if("if-needed"===l&&y>=0&&V>=0&&M<=g&&E<=m&&y>=R&&M<=Y&&V>=L&&E<=X)return C;var S=getComputedStyle(k),j=parseInt(S.borderLeftWidth,10),q=parseInt(S.borderTopWidth,10),z=parseInt(S.borderRightWidth,10),A=parseInt(S.borderBottomWidth,10),F=0,G=0,J="offsetWidth"in k?k.offsetWidth-k.clientWidth-j-z:0,K="offsetHeight"in k?k.offsetHeight-k.clientHeight-q-A:0;if(f===k)F="start"===d?x:"end"===d?x-g:"nearest"===d?r(v,v+g,g,q,A,v+x,v+x+b,b):x-g/2,G="start"===u?I:"center"===u?I-m/2:"end"===u?I-m:r(w,w+m,m,j,z,w+I,w+I+H,H),F=Math.max(0,F+v),G=Math.max(0,G+w);else{F="start"===d?x-R-q:"end"===d?x-Y+A+K:"nearest"===d?r(R,Y,D,q,A+K,x,x+b,b):x-(R+D/2)+K/2,G="start"===u?I-L-j:"center"===u?I-(L+O/2)+J/2:"end"===u?I-X+z+J:r(L,X,O,j,z+J,I,I+H,H);var N=k.scrollLeft,P=k.scrollTop;x+=P-(F=Math.max(0,Math.min(P+F,k.scrollHeight-D+K))),I+=N-(G=Math.max(0,Math.min(N+G,k.scrollWidth-O+J)))}C.push({el:k,top:F,left:G})}return C}
//# sourceMappingURL=index.module.js.map


/***/ }),

/***/ "./node_modules/lath/app/auto.cjs-a3a1c99b.js":
/*!****************************************************!*\
  !*** ./node_modules/lath/app/auto.cjs-a3a1c99b.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

function _interopDefaultLegacy(l){return l&&"object"==typeof l&&"default"in l?l:{default:l}}var install=__webpack_require__(/*! scroll-polyfill */ "./node_modules/scroll-polyfill/dist/index.esm.js"),install__default=_interopDefaultLegacy(install);install__default.default();

/***/ }),

/***/ "./node_modules/scroll-polyfill/dist/index.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/scroll-polyfill/dist/index.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ polyfill),
/* harmony export */   "scroll": () => (/* binding */ scroll),
/* harmony export */   "scrollBy": () => (/* binding */ scrollBy),
/* harmony export */   "scrollIntoView": () => (/* binding */ scrollIntoView),
/* harmony export */   "scrollTo": () => (/* binding */ scrollTo)
/* harmony export */ });
/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! compute-scroll-into-view */ "./node_modules/compute-scroll-into-view/dist/index.module.js");
/* harmony import */ var wobble__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wobble */ "./node_modules/wobble/dist/wobble.es.js");



// @see https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions
const defaultScrollToOptions = {
    behavior: 'auto',
    left: undefined,
    top: undefined,
};
// @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollInToView
const defaultScrollIntoViewOptions = {
    behavior: 'auto',
    block: 'start',
    inline: 'nearest',
};
const doScroll = (target, left, top, behavior) => {
    if (behavior === 'smooth') {
        return smoothScroll(target, left, top);
    }
    // scroll({left: NaN, top: NaN}) => scroll({})
    if (!isNaN(left)) {
        target.scrollLeft = left;
    }
    if (!isNaN(top)) {
        target.scrollTop = top;
    }
};
const defaultSpringConfig = {
    stiffness: 170,
    damping: 26,
    mass: 1,
    restVelocityThreshold: 0.01,
    restDisplacementThreshold: 0.1,
};
const spring = (fromValue, toValue, update) => new Promise((r) => new wobble__WEBPACK_IMPORTED_MODULE_0__.Spring(Object.assign(Object.assign({}, defaultSpringConfig), { fromValue, toValue }))
    .onUpdate((s) => update(s.currentValue))
    .onStop(() => r(void 0))
    .start());
const smoothScroll = (target, x, y) => {
    const scrollX = () => {
        if (isNaN(x)) {
            return;
        }
        const startX = target.scrollLeft;
        if (startX === x) {
            return;
        }
        return spring(startX, x, (v) => (target.scrollLeft = v));
    };
    const scrollY = () => {
        if (isNaN(y)) {
            return;
        }
        const startY = target.scrollTop;
        if (startY === y) {
            return;
        }
        return spring(startY, y, (v) => (target.scrollTop = v));
    };
    return Promise.all([scrollX(), scrollY()]);
};
const clampOptions = (target, { left, top }) => {
    const isRootScroller = target === getScrollingElement(target.ownerDocument);
    const clampX = () => {
        if (isNaN(left)) {
            return;
        }
        const scrollportWidth = isRootScroller
            ? target.ownerDocument.documentElement.clientWidth // for IE & Edge
            : target.clientWidth;
        const scrollLeftMax = target.scrollWidth - scrollportWidth;
        return clamp(left, 0, scrollLeftMax);
    };
    const clampY = () => {
        if (isNaN(top)) {
            return;
        }
        const scrollportHeight = isRootScroller
            ? target.ownerDocument.documentElement.clientHeight
            : target.clientHeight;
        const scrollTopMax = target.scrollHeight - scrollportHeight;
        return clamp(top, 0, scrollTopMax);
    };
    return { left: clampX(), top: clampY() };
};
const clamp = (value, min, max) => {
    return Math.min(Math.max(value, min), max);
};
const isObject = (val) => {
    const type = typeof val;
    return (type === 'object' && val != null) || type === 'function';
};
const isWindow = (obj) => obj.window === obj;
// @see: https://codesandbox.io/s/assert-scrolltooptions-y5bm4
const assertScrollToOptions = (options, target, method) => {
    if (!isObject(options)) {
        const ctor = isWindow(target) ? 'Window' : 'Element';
        throw new TypeError(`Failed to execute '${method}' on '${ctor}': parameter 1 ('options') is not an object.`);
    }
};
const getScrollingElement = (doc) => {
    // more robust: https://github.com/mathiasbynens/document.scrollingElement
    return doc.scrollingElement || doc.documentElement;
};
const normTarget = (obj) => isWindow(obj)
    ? getScrollingElement(obj.document)
    : obj;
const isDetached = (target) => {
    return !(target && target.ownerDocument.documentElement.contains(target));
};
const createScrollTo = (method, mapOptions) => {
    return (target, options) => {
        if (options == null) {
            return;
        }
        assertScrollToOptions(options, target, method);
        target = normTarget(target);
        if (isDetached(target)) {
            return;
        }
        const opts = Object.assign(Object.assign({}, defaultScrollToOptions), options);
        const finalOpts = mapOptions ? mapOptions(opts, target) : opts;
        const { left, top } = clampOptions(target, finalOpts);
        return doScroll(target, left, top, finalOpts.behavior);
    };
};
const scrollTo = createScrollTo('scrollTo');
const scroll = createScrollTo('scroll');
const scrollBy = createScrollTo('scrollBy', (opts, target) => {
    if (!isNaN(opts.left)) {
        opts.left += target.scrollLeft;
    }
    if (!isNaN(opts.top)) {
        opts.top += target.scrollTop;
    }
    return opts;
});
const scrollIntoView = (target, options) => {
    target = normTarget(target);
    if (isDetached(target)) {
        return;
    }
    const opts = Object.assign(Object.assign({}, defaultScrollIntoViewOptions), (isObject(options)
        ? options
        : !(options == null || Boolean(options)) && { block: 'end' }));
    return Promise.all((0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_1__["default"])(target, opts).map(({ el, top, left }) => doScroll(el, left, top, opts.behavior))).then(() => { });
};
const polyfillScrollToOptions = (scope, method) => {
    const nativeMethod = scope[method];
    const isScrollBy = method === 'scrollBy';
    const fallbackMethod = isScrollBy
        ? function (x, y) {
            // scrollBy(NaN, NaN) => no effect
            scrollBy(this, {
                left: isNaN(x) ? undefined : Number(x),
                top: isNaN(y) ? undefined : Number(y),
            });
        }
        : function (x, y) {
            // scroll(NaN, NaN) => scroll(0, 0)
            scrollTo(this, { left: Number(x) || 0, top: Number(y) || 0 });
        };
    scope[method] = function () {
        if (arguments.length === 1) {
            return (isScrollBy ? scrollBy : scrollTo)(this, arguments[0]);
        }
        return (nativeMethod || fallbackMethod).apply(this, arguments);
    };
    return () => {
        scope[method] = nativeMethod;
    };
};
const polyfillScrollToViewOptions = () => {
    const nativeMethod = Element.prototype.scrollIntoView;
    const fallbackMethod = function (alignToTop) {
        return scrollIntoView(this, alignToTop);
    };
    Element.prototype.scrollIntoView = function () {
        const options = arguments[0];
        if (isObject(options)) {
            return scrollIntoView(this, options);
        }
        return (nativeMethod || fallbackMethod).apply(this, arguments);
    };
    return () => {
        Element.prototype.scrollIntoView = nativeMethod;
    };
};
const polyfill = ({ force = false } = {}) => {
    if (typeof document !== 'undefined' &&
        (force || !('scrollBehavior' in document.documentElement.style))) {
        const undoFns = [
            polyfillScrollToOptions(window, 'scroll'),
            polyfillScrollToOptions(window, 'scrollBy'),
            polyfillScrollToOptions(window, 'scrollTo'),
            polyfillScrollToOptions(Element.prototype, 'scroll'),
            polyfillScrollToOptions(Element.prototype, 'scrollBy'),
            polyfillScrollToOptions(Element.prototype, 'scrollTo'),
            polyfillScrollToViewOptions(),
        ];
        return () => {
            undoFns.forEach((f) => f());
        };
    }
    return () => { };
};




/***/ }),

/***/ "./node_modules/wobble/dist/wobble.es.js":
/*!***********************************************!*\
  !*** ./node_modules/wobble/dist/wobble.es.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spring": () => (/* binding */ Spring)
/* harmony export */ });
/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */
function invariant(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}
function withDefault(maybeValue, defaultValue) {
    return typeof maybeValue !== "undefined" && maybeValue !== null
        ? maybeValue
        : defaultValue;
}

/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */
/**
 * Implements a spring physics simulation based on the equations behind
 * damped harmonic oscillators (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).
 */
class Spring {
    constructor(config = {}) {
        this._listeners = [];
        this._currentAnimationStep = 0; // current requestAnimationFrame
        this._currentTime = 0; // Current timestamp of animation in ms (real time)
        this._springTime = 0; // Current time along the spring curve in ms (zero-based)
        this._currentValue = 0; // the current value of the spring
        this._currentVelocity = 0; // the current velocity of the spring
        this._isAnimating = false;
        this._oscillationVelocityPairs = [];
        this._config = {
            fromValue: withDefault(config.fromValue, 0),
            toValue: withDefault(config.toValue, 1),
            stiffness: withDefault(config.stiffness, 100),
            damping: withDefault(config.damping, 10),
            mass: withDefault(config.mass, 1),
            initialVelocity: withDefault(config.initialVelocity, 0),
            overshootClamping: withDefault(config.overshootClamping, false),
            allowsOverdamping: withDefault(config.allowsOverdamping, false),
            restVelocityThreshold: withDefault(config.restVelocityThreshold, 0.001),
            restDisplacementThreshold: withDefault(config.restDisplacementThreshold, 0.001)
        };
        this._currentValue = this._config.fromValue;
        this._currentVelocity = this._config.initialVelocity;
    }
    /**
     * If `fromValue` differs from `toValue`, or `initialVelocity` is non-zero,
     * start the simulation and call the `onStart` listeners.
     */
    start() {
        const { fromValue, toValue, initialVelocity } = this._config;
        if (fromValue !== toValue || initialVelocity !== 0) {
            this._reset();
            this._isAnimating = true;
            if (!this._currentAnimationStep) {
                this._notifyListeners("onStart");
                this._currentAnimationStep = requestAnimationFrame((t) => {
                    this._step(Date.now());
                });
            }
        }
        return this;
    }
    /**
     * If a simulation is in progress, stop it and call the `onStop` listeners.
     */
    stop() {
        if (!this._isAnimating) {
            return this;
        }
        this._isAnimating = false;
        this._notifyListeners("onStop");
        if (this._currentAnimationStep) {
            cancelAnimationFrame(this._currentAnimationStep);
            this._currentAnimationStep = 0;
        }
        return this;
    }
    /**
     * The spring's current position.
     */
    get currentValue() {
        return this._currentValue;
    }
    /**
     * The spring's current velocity in units / ms.
     */
    get currentVelocity() {
        return this._currentVelocity; // give velocity in units/ms;
    }
    /**
     * If the spring has reached its `toValue`, or if its velocity is below the
     * `restVelocityThreshold`, it is considered at rest. If `stop()` is called
     * during a simulation, both `isAnimating` and `isAtRest` will be false.
     */
    get isAtRest() {
        return this._isSpringAtRest();
    }
    /**
     * Whether or not the spring is currently emitting values.
     *
     * Note: this is distinct from whether or not it is at rest.
     * See also `isAtRest`.
     */
    get isAnimating() {
        return this._isAnimating;
    }
    /**
     * Updates the spring config with the given values.  Values not explicitly
     * supplied will be reused from the existing config.
     */
    updateConfig(updatedConfig) {
        // When we update the spring config, we reset the simulation to ensure the
        // spring always moves the full distance between `fromValue` and `toValue`.
        // To ensure that the simulation behaves correctly if those values aren't
        // being changed in `updatedConfig`, we run the simulation with `_step()`
        // and default `fromValue` and `initialVelocity` to their current values.
        this._advanceSpringToTime(Date.now());
        const baseConfig = {
            fromValue: this._currentValue,
            initialVelocity: this._currentVelocity
        };
        this._config = Object.assign({}, this._config, baseConfig, updatedConfig);
        this._reset();
        return this;
    }
    /**
     * The provided callback will be invoked when the simulation begins.
     */
    onStart(listener) {
        this._listeners.push({ onStart: listener });
        return this;
    }
    /**
     * The provided callback will be invoked on each frame while the simulation is
     * running.
     */
    onUpdate(listener) {
        this._listeners.push({ onUpdate: listener });
        return this;
    }
    /**
     * The provided callback will be invoked when the simulation ends.
     */
    onStop(listener) {
        this._listeners.push({ onStop: listener });
        return this;
    }
    /**
     * Remove a single listener from this spring.
     */
    removeListener(listenerFn) {
        this._listeners = this._listeners.reduce((result, listener) => {
            const foundListenerFn = Object.values(listener).indexOf(listenerFn) !== -1;
            if (!foundListenerFn) {
                result.push(listener);
            }
            return result;
        }, []);
        return this;
    }
    /**
     * Removes all listeners from this spring.
     */
    removeAllListeners() {
        this._listeners = [];
        return this;
    }
    _reset() {
        this._currentTime = Date.now();
        this._springTime = 0.0;
        this._currentValue = this._config.fromValue;
        this._currentVelocity = this._config.initialVelocity;
    }
    _notifyListeners(eventName) {
        this._listeners.forEach((listener) => {
            const maybeListenerFn = listener[eventName];
            if (typeof maybeListenerFn === "function") {
                maybeListenerFn(this);
            }
        });
    }
    /**
     * `_step` is the main loop.  While the animation is running, it updates the
     * current state once per frame, and schedules the next frame if the spring is
     * not yet at rest.
     */
    _step(timestamp) {
        this._advanceSpringToTime(timestamp, true);
        // check `_isAnimating`, in case `stop()` got called during
        // `_advanceSpringToTime()`
        if (this._isAnimating) {
            this._currentAnimationStep = requestAnimationFrame((t) => this._step(Date.now()));
        }
    }
    _advanceSpringToTime(timestamp, shouldNotifyListeners = false) {
        // `_advanceSpringToTime` updates `_currentTime` and triggers the listeners.
        // Because of these side effects, it's only safe to call when an animation
        // is already in-progress.
        if (!this._isAnimating) {
            return;
        }
        let deltaTime = timestamp - this._currentTime;
        // If for some reason we lost a lot of frames (e.g. process large payload or
        // stopped in the debugger), we only advance by 4 frames worth of
        // computation and will continue on the next frame. It's better to have it
        // running at slower speed than jumping to the end.
        if (deltaTime > Spring.MAX_DELTA_TIME_MS) {
            deltaTime = Spring.MAX_DELTA_TIME_MS;
        }
        this._springTime += deltaTime;
        const c = this._config.damping;
        const m = this._config.mass;
        const k = this._config.stiffness;
        const fromValue = this._config.fromValue;
        const toValue = this._config.toValue;
        const v0 = -this._config.initialVelocity;
        invariant(m > 0, "Mass value must be greater than 0");
        invariant(k > 0, "Stiffness value must be greater than 0");
        invariant(c > 0, "Damping value must be greater than 0");
        let zeta = c / (2 * Math.sqrt(k * m)); // damping ratio (dimensionless)
        const omega0 = Math.sqrt(k / m) / 1000; // undamped angular frequency of the oscillator (rad/ms)
        const omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay
        const omega2 = omega0 * Math.sqrt(zeta * zeta - 1.0); // frequency of damped oscillation
        const x0 = toValue - fromValue; // initial displacement of the spring at t = 0
        if (zeta > 1 && !this._config.allowsOverdamping) {
            zeta = 1;
        }
        let oscillation = 0.0;
        let velocity = 0.0;
        const t = this._springTime;
        if (zeta < 1) {
            // Under damped
            const envelope = Math.exp(-zeta * omega0 * t);
            oscillation =
                toValue -
                    envelope *
                        ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) +
                            x0 * Math.cos(omega1 * t));
            // This looks crazy -- it's actually just the derivative of the
            // oscillation function
            velocity =
                zeta *
                    omega0 *
                    envelope *
                    (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 +
                        x0 * Math.cos(omega1 * t)) -
                    envelope *
                        (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) -
                            omega1 * x0 * Math.sin(omega1 * t));
        }
        else if (zeta === 1) {
            // Critically damped
            const envelope = Math.exp(-omega0 * t);
            oscillation = toValue - envelope * (x0 + (v0 + omega0 * x0) * t);
            velocity =
                envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
        }
        else {
            // Overdamped
            const envelope = Math.exp(-zeta * omega0 * t);
            oscillation =
                toValue -
                    envelope *
                        ((v0 + zeta * omega0 * x0) * Math.sinh(omega2 * t) +
                            omega2 * x0 * Math.cosh(omega2 * t)) /
                        omega2;
            velocity =
                envelope *
                    zeta *
                    omega0 *
                    (Math.sinh(omega2 * t) * (v0 + zeta * omega0 * x0) +
                        x0 * omega2 * Math.cosh(omega2 * t)) /
                    omega2 -
                    envelope *
                        (omega2 * Math.cosh(omega2 * t) * (v0 + zeta * omega0 * x0) +
                            omega2 * omega2 * x0 * Math.sinh(omega2 * t)) /
                        omega2;
        }
        this._currentTime = timestamp;
        this._currentValue = oscillation;
        this._currentVelocity = velocity;
        if (!shouldNotifyListeners) {
            return;
        }
        this._notifyListeners("onUpdate");
        if (!this._isAnimating) {
            // a listener might have stopped us in _onUpdate
            return;
        }
        // If the Spring is overshooting (when overshoot clamping is on), or if the
        // spring is at rest (based on the thresholds set in the config), stop the
        // animation.
        if (this._isSpringOvershooting() || this._isSpringAtRest()) {
            if (k !== 0) {
                // Ensure that we end up with a round value
                this._currentValue = toValue;
                this._currentVelocity = 0;
                this._notifyListeners("onUpdate");
            }
            this.stop();
            return;
        }
    }
    _isSpringOvershooting() {
        const { stiffness, fromValue, toValue, overshootClamping } = this._config;
        let isOvershooting = false;
        if (overshootClamping && stiffness !== 0) {
            if (fromValue < toValue) {
                isOvershooting = this._currentValue > toValue;
            }
            else {
                isOvershooting = this._currentValue < toValue;
            }
        }
        return isOvershooting;
    }
    _isSpringAtRest() {
        const { stiffness, toValue, restDisplacementThreshold, restVelocityThreshold } = this._config;
        const isNoVelocity = Math.abs(this._currentVelocity) <= restVelocityThreshold;
        const isNoDisplacement = stiffness !== 0 &&
            Math.abs(toValue - this._currentValue) <= restDisplacementThreshold;
        return isNoDisplacement && isNoVelocity;
    }
}
Spring.MAX_DELTA_TIME_MS = 1 / 60 * 1000 * 4; // advance 4 frames at max


//# sourceMappingURL=wobble.es.js.map


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_lath_app_auto_cjs-a3a1c99b_js.js.map